function e(e){return e&&'object'==typeof e&&'default'in e?e.default:e}function t(e,t){return t.displayName=e,t}function n(e,t){const n=effector.is.unit(e);let r={};n?r={unit:e}:'@@unitShape'in e?'function'==typeof e['@@unitShape']?r=e['@@unitShape']():d('expect @@unitShape to be a function'):r=e;const s=Array.isArray(r),o=p.useRef({stale:1,justSubscribed:0,scope:t}),[u,c,a,i,f]=p.useMemo((()=>{o.current.stale=1;const e=Array.isArray(r)?[]:{},s=[],u=[],c=[],a=[];for(const o in r){if(!{}.hasOwnProperty.call(r,o))continue;const i=r[o];effector.is.unit(i)||d(`expect useUnit ${n?'argument':`value in key "${o}"`} to be a unit`),effector.is.event(i)||effector.is.effect(i)?(e[o]=t?effector.scopeBind(i,{scope:t}):i,c.push(o),a.push(i)):(e[o]=null,s.push(o),u.push(i))}return[e,s,u,c,a]}),[o,t,...Object.keys(r),...Object.values(r)]),y=p.useRef({value:u,storeKeys:c,eventKeys:i,eventValues:f}),m=p.useCallback((e=>{const n=o.current;return n.justSubscribed=1,effector.createWatch({unit:a,fn:()=>{n.stale||(n.stale=1,e())},scope:t,batch:1})}),[a,t,y,o]),b=p.useCallback((()=>{const e=y.current,r=o.current;let l,p=0;const d=e.value,m=e.storeKeys,b=e.eventKeys,h=e.eventValues,k=t!==r.scope;if(r.stale||r.justSubscribed||k){p=!r.justSubscribed||k,l=s?[...u]:{...u},m.length===c.length&&b.length===i.length||(p=1);for(let e=0;e<c.length;e++){const n=v(a[e],t),r=c[e];p||(p=m.includes(r)?d[r]!==n:1),l[r]=n}for(let e=0;e<i.length;e++){const t=f[e],n=i[e];p||(p=b.includes(n)?h[b.indexOf(n)]!==t:1)}}return p&&(e.value=l),e.storeKeys=c,e.eventKeys=i,e.eventValues=f,r.stale=0,r.justSubscribed=!p,r.scope=t,n?e.value.unit:e.value}),[m,a,f,t,y,o]);return l.useSyncExternalStore(m,b,b)}function r([e,t],n){let r,s,o,u,c=b;t?(r=t,o=e,u=[]):({fn:r,store:o,keys:u,defaultValue:s,updateFilter:c=b}=e),effector.is.store(o)||d('useStoreMap expects a store'),Array.isArray(u)||d('useStoreMap expects an array as keys'),'function'!=typeof r&&d('useStoreMap expects a function');const a=p.useCallback((e=>effector.createWatch({unit:o,fn:e,scope:n})),[o,n]),i=p.useCallback((()=>v(o,n)),[o,n]),l=p.useRef(),y=p.useRef(),m=p.useRef(u);return f.useSyncExternalStoreWithSelector(a,i,i,(e=>{if(l.current!==e||!((e,t)=>{if(!e||!t||e.length!==t.length)return 0;let n=1;for(let r=0;r<e.length;r++)if(e[r]!==t[r]){n=0;break}return n})(m.current,u)){let t=r(e,u);void 0===t&&void 0!==s&&(t=s),l.current=e,m.current=u,void 0!==t&&(y.current=t)}return y.current}),((e,t)=>!c(t,e)))}function s(e,t={},r){const{open:s,close:o,set:u}=n({open:e.open,close:e.close,set:e.set},r),c=p.useMemo((()=>({open:s,close:o,set:u})),[e,s]),a=p.useRef({value:null,count:0});y((()=>(c.open(a.current.value),()=>c.close(a.current.value))),[c]),((e,t)=>{if(e===t)return 1;if('object'==typeof e&&null!==e&&'object'==typeof t&&null!==t){const n=Object.keys(e),r=Object.keys(t);if(n.length!==r.length)return 0;for(let r=0;r<n.length;r++){const s=n[r];if(e[s]!==t[s])return 0}return 1}return 0})(a.current.value,t)||(a.current.value=t,a.current.count+=1),y((()=>{c.set(a.current.value)}),[a.current.count])}function o(e){const t=p.useContext(h);return e&&!t&&d('No scope found, consider adding <Provider> to app root'),t}function u(e,t){const n=t?e:e[0];var r;(e=>{if(!e)throw Error("expect first argument be an object")})(x(r=n)||(e=>'function'==typeof e)(r));let s=n.or;const o=n.and;if(o){const n=t?o:o[0];if(x(n)&&'and'in n){const n=u(o,t);e=n[0],s={...s,...n[1]}}else e=o}return[e,s]}function c(e,t){const n=t&&x(r=t[0])&&(r.and||r.or)?t:[{and:t}];var r;const[[s,o],c]=u(n);let a,i={},l={},f=c;var p;return'string'==typeof s?(l={name:s},x(p=o)&&'sid'in p||(i=o||{})):(e=>x(e)&&('domain'in e||'defaultState'in e||'name'in e))(s)&&(l=s,i=s.defaultState||{},a=s.domain),{hook:e,domain:a,defaultState:i,mainConfig:l,maybeConfig:f}}function a(e){return((e,t)=>{m(1,'useStore','useUnit'),effector.is.store(e)||d('expect useStore argument to be a store');const n=p.useCallback((n=>effector.createWatch({unit:e,fn:n,scope:t})),[e,t]),r=p.useCallback((()=>v(e,t)),[e,t]);return l.useSyncExternalStore(n,r,r)})(e,o(1))}Object.defineProperty(exports,'__esModule',{value:1});var i=require('react'),effector=require('effector'),l=require('use-sync-external-store/shim/index.js'),f=require('use-sync-external-store/shim/with-selector.js'),p=e(i);const d=e=>{throw Error(e)},y='undefined'!=typeof window?p.useLayoutEffect:p.useEffect,m=(e,t,n)=>{i.useEffect((()=>{e&&console.error(`${t} is deprecated${n?`, prefer ${n} instead`:''}`)}),[e,t,n])},v=(e,t)=>t?t.getState(e):e.getState(),b=(e,t)=>e!==t,h=p.createContext(null),{Provider:k}=h,x=e=>'object'==typeof e&&null!==e,S=(e,t={})=>(x(e)&&(S(e.or,t),(e=>{for(const s in e)r=s,(e=>void 0===e)(n=e[s])||'or'===r||'and'===r||(t[r]=n);var n,r})(e),S(e.and,t)),t),g=(e,t)=>{console.error(`${e} is deprecated${t?`, use ${t} instead`:''}`)};console.error('`effector-react/scope` is deprecated. Use `effector-react` directly instead'),exports.Provider=k,exports.connect=e=>(g('connect','useUnit'),n=>{let r=e;return'function'!=typeof e&&(r=n,n=e),t(`Connect(${r.displayName||r.name||'Unknown'})`,(e=>p.createElement(r,{...e,...a(n)})))}),exports.createComponent=()=>d('not implemented'),exports.createGate=(...e)=>(({domain:e,defaultState:n,hook:r,mainConfig:s,maybeConfig:u})=>{function c(e){return r(c,e,o()),null}const a=S({or:u,and:s}),i=`${e?`${e.compositeName.fullName}/`:''}${a.name||'gate'}`,l=effector.createEvent({name:`${i}.set`,sid:a.sid?`${a.sid}|set`:void 0}),f=effector.createEvent({name:`${i}.open`,sid:a.sid?`${a.sid}|open`:void 0}),p=effector.createEvent({name:`${i}.close`,sid:a.sid?`${a.sid}|close`:void 0}),d=effector.createStore(Boolean(0),{name:`${i}.status`,serialize:'ignore'}).on(f,(()=>Boolean(1))).on(p,(()=>Boolean(0))),y=effector.createStore(n,{name:`${i}.state`,sid:a.sid}).on(l,((e,t)=>t)).on(f,((e,t)=>t)).reset(p);if(e){const{hooks:t}=e;effector.launch({target:[t.store,t.store,t.event,t.event,t.event],params:[d,y,f,p,l]})}return c.open=f,c.close=p,c.status=d,c.state=y,c.set=l,t(`Gate:${i}`,c)})(c(s,e)),exports.createStoreConsumer=e=>(g('createStoreConsumer','useUnit'),t=>{const n=a(e);return t.children(n)}),exports.useEvent=e=>((e,t)=>{if(m(1,'useEvent','useUnit'),!t)return e;const n=effector.is.unit(e)||'object'!=typeof e?{event:e}:e;return p.useMemo((()=>{if(effector.is.unit(e))return effector.scopeBind(e,{scope:t});const n=Array.isArray(e)?[]:{};for(const r in e)n[r]=effector.scopeBind(e[r],{scope:t});return n}),[t,...Object.keys(n),...Object.values(n)])})(e,o(1)),exports.useGate=(e,t={})=>s(e,t,o(1)),exports.useList=(e,s)=>((e,s,o)=>{let u,c,a,i=[];'object'==typeof s&&null!==s?(s.keys&&(i=s.keys),({fn:u,getKey:c,placeholder:a}=s)):u=s,effector.is.store(e)||d('expect useList first argument to be a store'),'function'!=typeof u&&d("expect useList's renderItem to be a function"),Array.isArray(i)||d("expect useList's keys to be an array");const l=p.useMemo((()=>{const n=t(`${e.shortName||'Unknown'}.Item`,(t=>{const{index:n,keys:s,keyVal:u,value:c}=t;if(f.current[1])return f.current[0](c,u);const a=r([{store:e,keys:[n,...s],fn:(e,t)=>e[t[0]]}],o);return f.current[0](a,n)}));return p.memo(n)}),[e,o,!!c]),f=p.useRef([u,c]);f.current=[u,c];const y=p.useMemo((()=>i),i);if(c){const t=n(e,o);return 0===t.length&&a?a:t.map((e=>{const t=f.current[1](e);return p.createElement(l,{keyVal:t,key:t,keys:y,value:e})}))}{const t=r([{store:e,keys:[e],fn:e=>e.length}],o);return 0===t&&a?a:Array.from({length:t},((e,t)=>p.createElement(l,{index:t,key:t,keys:y})))}})(e,s,o(1)),exports.useStore=a,exports.useStoreMap=(e,t)=>{const n=o(1);return r(t?[e,t]:[{store:e.store,keys:e.keys,fn:e.fn,updateFilter:e.updateFilter}],n)},exports.useUnit=e=>n(e,o(1));
//# sourceMappingURL=scope.js.map
