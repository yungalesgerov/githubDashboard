{"version":3,"file":"scope.js","sources":["effector-react/withDisplayName.ts","effector-react/apiBase.ts","effector-react/scope.ts","effector-react/../effector/config.ts","effector-react/../effector/is.ts","effector-react/../effector/throw.ts","effector-react/createGate.ts","effector-react/ssr.ts","effector-react/throw.ts","effector-react/useIsomorphicLayoutEffect.ts","effector-react/useDeprecate.ts","effector-react/../effector/collection.ts","effector-react/deprecate.ts","effector-react/../../packages/effector-react/scope.ts"],"sourcesContent":["export function withDisplayName(name: string, Component: any) {\n  Component.displayName = name\n  return Component\n}\n","import {Store, is, scopeBind, Scope, Unit, Event, createWatch} from 'effector'\nimport React from 'react'\nimport {useSyncExternalStore} from 'use-sync-external-store/shim'\nimport {useSyncExternalStoreWithSelector} from 'use-sync-external-store/shim/with-selector'\nimport {throwError} from './throw'\nimport {withDisplayName} from './withDisplayName'\nimport {useIsomorphicLayoutEffect} from './useIsomorphicLayoutEffect'\nimport {Gate} from './index.h'\nimport {useDeprecate} from './useDeprecate'\n\nconst stateReader = <T>(store: Store<T>, scope?: Scope) =>\n  scope ? scope.getState(store) : store.getState()\nconst basicUpdateFilter = <T>(upd: T, oldValue: T) => upd !== oldValue\nconst keysEqual = (a?: readonly any[], b?: readonly any[]) => {\n  if (!a || !b || a.length !== b.length) return false\n\n  let isEqual = true\n\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      isEqual = false\n      break\n    }\n  }\n\n  return isEqual\n}\n\nexport function useStoreBase<State>(store: Store<State>, scope?: Scope) {\n  useDeprecate(true, 'useStore', 'useUnit')\n  if (!is.store(store)) throwError('expect useStore argument to be a store')\n\n  const subscribe = React.useCallback(\n    (fn: () => void) => createWatch({unit: store, fn, scope}),\n    [store, scope],\n  )\n  const read = React.useCallback(\n    () => stateReader(store, scope),\n    [store, scope],\n  )\n  const currentValue = useSyncExternalStore(subscribe, read, read)\n\n  return currentValue\n}\n\nexport function useUnitBase<Shape extends {[key: string]: Unit<any>}>(\n  shape: Shape | {'@@unitShape': () => Shape},\n  scope?: Scope,\n) {\n  const isSingleUnit = is.unit(shape)\n  let normShape: {[key: string]: Unit<any>} = {}\n  if (isSingleUnit) {\n    normShape = {unit: shape}\n  } else if ('@@unitShape' in shape) {\n    if (typeof shape['@@unitShape'] === 'function') {\n      normShape = shape['@@unitShape']()\n    } else {\n      throwError('expect @@unitShape to be a function')\n    }\n  } else {\n    normShape = shape\n  }\n  const isList = Array.isArray(normShape)\n  const flagsRef = React.useRef({\n    stale: true,\n    justSubscribed: false,\n    scope,\n  })\n  const [eventsShape, storeKeys, storeValues, eventKeys, eventValues] =\n    React.useMemo(() => {\n      flagsRef.current.stale = true\n      const shape = Array.isArray(normShape) ? [] : ({} as any)\n      const storeKeys: string[] = []\n      const storeValues: Array<Store<any>> = []\n      const eventKeys: string[] = []\n      const eventValues: Array<Unit<any>> = []\n      for (const key in normShape) {\n        if (!Object.prototype.hasOwnProperty.call(normShape, key)) continue\n        const unit = normShape[key]\n        if (!is.unit(unit)) {\n          const keyMessage = isSingleUnit ? 'argument' : `value in key \"${key}\"`\n          throwError(`expect useUnit ${keyMessage} to be a unit`)\n        }\n        if (is.event(unit) || is.effect(unit)) {\n          shape[key] = scope ? scopeBind(unit as Event<any>, {scope}) : unit\n          eventKeys.push(key)\n          eventValues.push(unit)\n        } else {\n          shape[key] = null\n          storeKeys.push(key)\n          storeValues.push(unit as Store<any>)\n        }\n      }\n      return [shape, storeKeys, storeValues, eventKeys, eventValues]\n    }, [\n      flagsRef,\n      scope,\n      ...Object.keys(normShape),\n      ...Object.values(normShape),\n    ])\n  const stateRef = React.useRef({\n    value: eventsShape,\n    storeKeys,\n    eventKeys,\n    eventValues,\n  })\n  const subscribe = React.useCallback(\n    (cb: () => void) => {\n      const flags = flagsRef.current\n      flags.justSubscribed = true\n      const cbCaller = () => {\n        if (!flags.stale) {\n          flags.stale = true\n          cb()\n        }\n      }\n      return createWatch({unit: storeValues, fn: cbCaller, scope, batch: true})\n    },\n    [storeValues, scope, stateRef, flagsRef],\n  )\n  const read = React.useCallback(() => {\n    const state = stateRef.current\n    const flags = flagsRef.current\n    let resultValue\n    let changed = false\n    const oldVal = state.value\n    const oldStoreKeys = state.storeKeys\n    const oldEventKeys = state.eventKeys\n    const oldEventValues = state.eventValues\n    const scopeChanged = scope !== flags.scope\n    if (flags.stale || flags.justSubscribed || scopeChanged) {\n      changed = !flags.justSubscribed || scopeChanged\n      resultValue = isList ? [...eventsShape] : {...eventsShape}\n      if (\n        oldStoreKeys.length !== storeKeys.length ||\n        oldEventKeys.length !== eventKeys.length\n      ) {\n        changed = true\n      }\n      for (let i = 0; i < storeKeys.length; i++) {\n        const updatedValue = stateReader(storeValues[i], scope)\n        const key = storeKeys[i]\n        if (!changed) {\n          if (!oldStoreKeys.includes(key)) {\n            changed = true\n          } else {\n            changed = oldVal[key] !== updatedValue\n          }\n        }\n        resultValue[key] = updatedValue\n      }\n      for (let i = 0; i < eventKeys.length; i++) {\n        const updatedValue = eventValues[i]\n        const key = eventKeys[i]\n        if (!changed) {\n          if (!oldEventKeys.includes(key)) {\n            changed = true\n          } else {\n            changed = oldEventValues[oldEventKeys.indexOf(key)] !== updatedValue\n          }\n        }\n      }\n    }\n    if (changed) {\n      state.value = resultValue\n    }\n    state.storeKeys = storeKeys\n    state.eventKeys = eventKeys\n    state.eventValues = eventValues\n    flags.stale = false\n    flags.justSubscribed = !changed\n    flags.scope = scope\n    return isSingleUnit ? state.value.unit : state.value\n  }, [subscribe, storeValues, eventValues, scope, stateRef, flagsRef])\n  return useSyncExternalStore(subscribe, read, read)\n}\n\nexport function useStoreMapBase<State, Result, Keys extends ReadonlyArray<any>>(\n  [configOrStore, separateFn]: [\n    configOrStore:\n      | {\n          store: Store<State>\n          keys: Keys\n          fn(state: State, keys: Keys): Result\n          updateFilter?: (update: Result, current: Result) => boolean\n          defaultValue?: Result\n        }\n      | Store<State>,\n    separateFn?: (state: State, keys: Keys) => Result,\n  ],\n  scope?: Scope,\n): Result {\n  let fn: (state: State, keys: Keys) => Result\n  let updateFilter: (update: Result, current: Result) => boolean =\n    basicUpdateFilter\n  let defaultValue: Result | undefined\n  let store: Store<State>\n  let keys: Keys\n  if (separateFn) {\n    fn = separateFn\n    store = configOrStore as Store<State>\n    keys = [] as unknown as Keys\n  } else {\n    ;({\n      fn,\n      store,\n      keys,\n      defaultValue,\n      updateFilter = basicUpdateFilter,\n    } = configOrStore as any)\n  }\n  if (!is.store(store)) throwError('useStoreMap expects a store')\n  if (!Array.isArray(keys)) throwError('useStoreMap expects an array as keys')\n  if (typeof fn !== 'function') throwError('useStoreMap expects a function')\n\n  const subscribe = React.useCallback(\n    (fn: () => void) => createWatch({unit: store, fn, scope}),\n    [store, scope],\n  )\n  const read = React.useCallback(\n    () => stateReader(store, scope),\n    [store, scope],\n  )\n\n  const stateRef = React.useRef<State>()\n  const valueRef = React.useRef<Result>()\n  const keysRef = React.useRef(keys)\n\n  const value = useSyncExternalStoreWithSelector(\n    subscribe,\n    read,\n    read,\n    state => {\n      if (stateRef.current !== state || !keysEqual(keysRef.current, keys)) {\n        let result = fn(state, keys)\n        if (result === undefined && defaultValue !== undefined) {\n          result = defaultValue\n        }\n        stateRef.current = state\n        keysRef.current = keys\n\n        /**\n         * skip update, if undefined\n         * just like original store or previous implementation\n         */\n        if (result !== undefined) {\n          valueRef.current = result\n        }\n      }\n\n      return valueRef.current as Result\n    },\n    (current, update) => !updateFilter(update, current),\n  )\n\n  return value\n}\nexport function useListBase<T>(\n  list: Store<T[]>,\n  renderItem:\n    | {\n        keys?: any[]\n        fn(item: T, index: number): React.ReactNode\n        getKey?: (item: T) => string\n        placeholder?: React.ReactNode\n      }\n    | ((item: T, index: number) => React.ReactNode),\n  scope?: Scope,\n): React.ReactNode {\n  let keys = [] as any[]\n  let fn\n  let getKey: ((item: T) => string) | void\n  let placeholder: React.ReactNode | void\n  if (typeof renderItem === 'object' && renderItem !== null) {\n    if (renderItem.keys) keys = renderItem.keys\n    ;({fn, getKey, placeholder} = renderItem)\n  } else {\n    fn = renderItem\n  }\n  if (!is.store(list)) throwError('expect useList first argument to be a store')\n  if (typeof fn !== 'function')\n    throwError(\"expect useList's renderItem to be a function\")\n  if (!Array.isArray(keys)) throwError(\"expect useList's keys to be an array\")\n  const Item = React.useMemo(() => {\n    const Item = withDisplayName(\n      `${list.shortName || 'Unknown'}.Item`,\n      (\n        props:\n          | {index: number; keys: any[]; keyVal: never; value: never}\n          | {index: never; keys: any[]; keyVal: string; value: T},\n      ) => {\n        const {index, keys, keyVal, value} = props\n        const isKeyed = !!fnRef.current[1]\n        if (isKeyed) {\n          return fnRef.current[0](value, keyVal as any)\n        }\n        const item = useStoreMapBase(\n          [\n            {\n              store: list,\n              keys: [index, ...keys],\n              fn: (list, keys) => list[keys[0]],\n            },\n          ],\n          scope,\n        )\n        return fnRef.current[0](item, index)\n      },\n    )\n    return React.memo(Item)\n  }, [list, scope, !!getKey!])\n  const fnRef = React.useRef([fn, getKey!] as const)\n  fnRef.current = [fn, getKey!]\n  const keysSelfMemo = React.useMemo(() => keys, keys)\n  if (getKey!) {\n    const listItems = useUnitBase(list, scope)\n    if (listItems.length === 0 && placeholder) return placeholder\n    return listItems.map(value => {\n      const key = fnRef.current[1](value)\n      return React.createElement(Item, {\n        keyVal: key,\n        key,\n        keys: keysSelfMemo,\n        value,\n      })\n    })\n  } else {\n    const length = useStoreMapBase(\n      [\n        {\n          store: list,\n          keys: [list],\n          fn: list => list.length,\n        },\n      ],\n      scope,\n    )\n    if (length === 0 && placeholder) return placeholder\n    return Array.from({length}, (_, i) =>\n      React.createElement(Item, {\n        index: i,\n        key: i,\n        keys: keysSelfMemo,\n      }),\n    )\n  }\n}\n\nexport function useEventBase(eventObject: any, scope?: Scope) {\n  useDeprecate(true, 'useEvent', 'useUnit')\n  if (!scope) {\n    return eventObject\n  }\n  const isShape = !is.unit(eventObject) && typeof eventObject === 'object'\n  const events = isShape ? eventObject : {event: eventObject}\n\n  return React.useMemo(() => {\n    if (is.unit(eventObject)) {\n      //@ts-expect-error\n      return scopeBind(eventObject, {scope})\n    }\n    const shape = Array.isArray(eventObject) ? [] : ({} as any)\n    for (const key in eventObject) {\n      shape[key] = scopeBind(eventObject[key], {scope})\n    }\n    return shape\n  }, [scope, ...Object.keys(events), ...Object.values(events)])\n}\n\nexport function useGateBase<Props>(\n  GateComponent: Gate<Props>,\n  props: Props = {} as any,\n  scope?: Scope,\n) {\n  const {open, close, set} = useUnitBase(\n    {\n      open: GateComponent.open,\n      close: GateComponent.close,\n      set: GateComponent.set,\n    },\n    scope,\n  )\n  const ForkedGate = React.useMemo(\n    () =>\n      ({\n        open,\n        close,\n        set,\n      } as Gate<Props>),\n    [GateComponent, open],\n  )\n\n  const propsRef = React.useRef<{value: any; count: number}>({\n    value: null,\n    count: 0,\n  })\n  useIsomorphicLayoutEffect(() => {\n    ForkedGate.open(propsRef.current.value)\n    return () => ForkedGate.close(propsRef.current.value) as any\n  }, [ForkedGate])\n  if (!shallowCompare(propsRef.current.value, props)) {\n    propsRef.current.value = props\n    propsRef.current.count += 1\n  }\n  useIsomorphicLayoutEffect(() => {\n    ForkedGate.set(propsRef.current.value)\n  }, [propsRef.current.count])\n}\n\nfunction shallowCompare(a: any, b: any) {\n  if (a === b) return true\n  if (\n    typeof a === 'object' &&\n    a !== null &&\n    typeof b === 'object' &&\n    b !== null\n  ) {\n    const aKeys = Object.keys(a)\n    const bKeys = Object.keys(b)\n    if (aKeys.length !== bKeys.length) return false\n    for (let i = 0; i < aKeys.length; i++) {\n      const key = aKeys[i]\n      if (a[key] !== b[key]) return false\n    }\n    return true\n  }\n  return false\n}\n","import React from 'react'\nimport {Scope} from 'effector'\nimport {throwError} from './throw'\n\nconst ScopeContext = React.createContext(null as Scope | null)\nexport const {Provider} = ScopeContext\nexport function getScope(forceScope?: boolean) {\n  const scope = React.useContext(ScopeContext)\n  if (forceScope && !scope)\n    throwError('No scope found, consider adding <Provider> to app root')\n  return scope as Scope\n}\n","import {forIn} from './collection'\nimport {assertObject, isObject, isVoid} from './is'\n\nexport function processArgsToConfig(\n  arg: any,\n  singleArgument: true,\n): [any, any | void]\nexport function processArgsToConfig(args: any[]): [any[], any | void]\nexport function processArgsToConfig(\n  args: any[],\n  singleArgument?: boolean,\n): [any[], any | void] {\n  const rawConfig = singleArgument ? args : args[0]\n  assertObject(rawConfig)\n  let metadata = rawConfig.or\n  const childConfig = rawConfig.and\n  if (childConfig) {\n    const unwrappedNestedValue = singleArgument ? childConfig : childConfig[0]\n    /**\n     * if there is no \"and\" field then we reached the leaf of the tree\n     * and this is an original user-defined argument\n     *\n     * note that in this case we're returning all arguments, not the only one been unwrapped\n     **/\n    if (!isObject(unwrappedNestedValue) || !('and' in unwrappedNestedValue)) {\n      args = childConfig\n    } else {\n      //@ts-expect-error\n      const nested = processArgsToConfig(childConfig, singleArgument)\n\n      args = nested[0]\n      metadata = {...metadata, ...nested[1]}\n    }\n  }\n  return [args, metadata]\n}\n\n/**\nprocessed fields:\n\n'name',\n'sid',\n'loc',\n'handler',\n'updateFilter',\n'parent',\n'serialize',\n'named',\n'derived',\n*/\nexport const flattenConfig = (part: any, config: Record<string, any> = {}) => {\n  if (isObject(part)) {\n    flattenConfig(part.or, config)\n    forIn(part, (value, field) => {\n      if (!isVoid(value) && field !== 'or' && field !== 'and') {\n        config[field] = value\n      }\n    })\n    flattenConfig(part.and, config)\n  }\n  return config\n}\n","export * as is from './validate'\nimport {forEach} from './collection'\nimport {assert, deprecate} from './throw'\nimport {arrifyNodes} from './createNode'\nimport type {NodeUnit} from './index.h'\nimport type {DataCarrier} from './unit.h'\nimport {getMeta} from './getter'\n\nexport const isObject = (value: unknown): value is Record<any, any> =>\n  typeof value === 'object' && value !== null\nexport const isFunction = (value: unknown): value is Function =>\n  typeof value === 'function'\n\nexport const isVoid = (value: unknown): value is void => value === undefined\n\nexport const assertObject = (value: unknown) =>\n  assert(\n    isObject(value) || isFunction(value),\n    'expect first argument be an object',\n  ) // or function\n\nconst assertNodeSetItem = (\n  value: unknown,\n  method: string,\n  valueName: string,\n  reason: string,\n): asserts value is DataCarrier =>\n  assert(\n    !(\n      (!isObject(value) && !isFunction(value)) ||\n      (!('family' in value) && !('graphite' in value))\n    ),\n    `${method}: expect ${valueName} to be a unit (store, event or effect)${reason}`,\n  )\n\nexport const assertNodeSet = (\n  value: unknown,\n  method: string,\n  valueName: string,\n) => {\n  if (Array.isArray(value)) {\n    forEach(value, (item, i) =>\n      assertNodeSetItem(item, method, `${i} item of ${valueName}`, ''),\n    )\n  } else {\n    //@ts-expect-error some ts assertion edge case\n    assertNodeSetItem(value, method, valueName, ' or array of units')\n  }\n}\n\nexport const assertTarget = (\n  method: string,\n  target: NodeUnit | NodeUnit[],\n  targetField: string = 'target',\n) =>\n  forEach(arrifyNodes(target), item =>\n    assert(\n      !getMeta(item, 'derived'),\n      `${method}: derived unit in \"${targetField}\" is not supported, use createStore/createEvent instead\"`,\n    ),\n  )\n","export function assert(\n  condition: unknown,\n  message: string,\n  errorTitle?: string,\n): asserts condition {\n  if (!condition)\n    throw Error(`${errorTitle ? errorTitle + ': ' : ''}${message}`)\n}\n\nexport const deprecate = (\n  condition: unknown,\n  subject: string,\n  suggestion?: string,\n  errorTitle?: string,\n) =>\n  !condition &&\n  console.error(\n    `${errorTitle ? errorTitle + ': ' : ''}${subject} is deprecated${\n      suggestion ? `, use ${suggestion} instead` : ''\n    }`,\n  )\n","import {createStore, launch, Domain, createEvent} from 'effector'\nimport {Gate} from './index.h'\nimport {withDisplayName} from './withDisplayName'\nimport {useGateBase} from './apiBase'\nimport {getScope} from './scope'\nimport {flattenConfig, processArgsToConfig} from '../effector/config'\nimport {isObject} from '../effector/is'\n\nexport function createGateImplementation<State>({\n  domain,\n  defaultState,\n  hook: useGateHook,\n  mainConfig,\n  maybeConfig,\n}: {\n  domain?: Domain\n  defaultState: State | {}\n  hook: typeof useGateBase\n  mainConfig?: Record<string, any>\n  maybeConfig?: Record<string, any> & {sid?: string}\n}): Gate<State> {\n  const config = flattenConfig({\n    or: maybeConfig,\n    and: mainConfig,\n  }) as {sid: string | undefined; name: string | undefined}\n  const name = config.name || 'gate'\n  const fullName = `${domain ? `${domain.compositeName.fullName}/` : ''}${name}`\n  const set = createEvent<State>({\n    name: `${fullName}.set`,\n    sid: config.sid ? `${config.sid}|set` : undefined,\n  })\n  const open = createEvent<State>({\n    name: `${fullName}.open`,\n    sid: config.sid ? `${config.sid}|open` : undefined,\n  })\n  const close = createEvent<State>({\n    name: `${fullName}.close`,\n    sid: config.sid ? `${config.sid}|close` : undefined,\n  })\n  const status = createStore(Boolean(false), {\n    name: `${fullName}.status`,\n    serialize: 'ignore',\n    // doesn't need to have sid, because it is internal store, should not be serialized\n  })\n    .on(open, () => Boolean(true))\n    .on(close, () => Boolean(false))\n  const state = createStore(defaultState as State, {\n    name: `${fullName}.state`,\n    sid: config.sid,\n  })\n    .on(set, (_, state) => state)\n    .on(open, (_, state) => state)\n    .reset(close)\n  if (domain) {\n    const {hooks} = domain as any\n    launch({\n      target: [\n        hooks.store,\n        hooks.store,\n        hooks.event,\n        hooks.event,\n        hooks.event,\n      ] as any,\n      params: [status, state, open, close, set],\n    })\n  }\n  function GateComponent(props: State) {\n    useGateHook(GateComponent as any, props, getScope())\n    return null\n  }\n  GateComponent.open = open\n  GateComponent.close = close\n  GateComponent.status = status\n  GateComponent.state = state\n  GateComponent.set = set\n  return withDisplayName(`Gate:${fullName}`, GateComponent)\n}\n\nconst isPluginConfig = (config: Record<string, any> | string) =>\n  isObject(config) && 'sid' in config\n\nconst isGateConfig = (config: Record<string, any> | string) =>\n  isObject(config) &&\n  ('domain' in config || 'defaultState' in config || 'name' in config)\n\nconst isStructuredConfig = (arg: unknown) =>\n  isObject(arg) && (arg.and || arg.or)\n\nexport function processCreateGateConfig<State>(\n  hook: typeof useGateBase,\n  args: unknown[],\n): {\n  domain?: Domain\n  defaultState: State | {}\n  hook: typeof useGateBase\n  mainConfig?: Record<string, any>\n  maybeConfig?: Record<string, any> & {sid?: string}\n} {\n  const universalConfig =\n    args && isStructuredConfig(args[0]) ? args : [{and: args}]\n  const [[nameOrConfig, defaultStateOrConfig], metadata] =\n    processArgsToConfig(universalConfig)\n\n  let domain\n  let defaultState = {}\n  let mainConfig = {}\n  let maybeConfig = metadata\n\n  if (typeof nameOrConfig === 'string') {\n    mainConfig = {name: nameOrConfig}\n    if (isPluginConfig(defaultStateOrConfig)) {\n      // maybeConfig = defaultStateOrConfig\n    } else {\n      defaultState = defaultStateOrConfig || {}\n    }\n  } else if (isGateConfig(nameOrConfig)) {\n    mainConfig = nameOrConfig\n    defaultState = nameOrConfig.defaultState || {}\n    domain = nameOrConfig.domain\n  }\n  return {\n    hook,\n    domain,\n    defaultState,\n    mainConfig,\n    maybeConfig,\n  }\n}\n\nexport function createGate<Props>(...args: unknown[]): Gate<Props> {\n  return createGateImplementation<Props>(\n    processCreateGateConfig(useGateBase, args),\n  )\n}\n","import React from 'react'\nimport {Domain, Store} from 'effector'\nimport {\n  useStoreBase,\n  useUnitBase,\n  useStoreMapBase,\n  useListBase,\n  useEventBase,\n  useGateBase,\n} from './apiBase'\nimport {withDisplayName} from './withDisplayName'\nimport {createGateImplementation, processCreateGateConfig} from './createGate'\nimport type {Gate} from './index.h'\nimport {throwError} from './throw'\nimport {deprecate} from './deprecate'\nimport {getScope} from './scope'\n\nexport function createGate<Props>(\n  ...args: Array<\n    | {\n        domain?: Domain\n        defaultState?: Props\n        name?: string\n      }\n    | {}\n  >\n) {\n  return createGateImplementation(processCreateGateConfig(useGateBase, args))\n}\n\nexport function createStoreConsumer(store: any) {\n  deprecate('createStoreConsumer', 'useUnit')\n  return (props: any) => {\n    const state = useStore(store)\n    return props.children(state)\n  }\n}\n\nexport const createComponent = (shape: any) => throwError('not implemented')\n\nexport const connect = (Component: any) => {\n  deprecate('connect', 'useUnit')\n  return (store: any) => {\n    let View: any = Component\n    if (typeof Component !== 'function') {\n      View = store\n      store = Component as any\n    }\n    const wrappedComponentName = View.displayName || View.name || 'Unknown'\n    return withDisplayName(`Connect(${wrappedComponentName})`, (props: any) =>\n      React.createElement(View, {...props, ...(useStore(store) as any)}),\n    )\n  }\n}\n/** useStore wrapper for scopes */\nexport function useStore<T>(store: Store<T>): T {\n  return useStoreBase(store, getScope(true))\n}\nexport function useUnit(shape) {\n  return useUnitBase(shape, getScope(true))\n}\n/** useList wrapper for scopes */\nexport function useList(store: any, opts: any) {\n  return useListBase(store, opts, getScope(true))\n}\n/** useStoreMap wrapper for scopes */\nexport function useStoreMap(configOrStore: any, separateFn: any) {\n  const scope = getScope(true)\n  if (separateFn) return useStoreMapBase([configOrStore, separateFn], scope)\n  return useStoreMapBase(\n    [\n      {\n        store: configOrStore.store,\n        keys: configOrStore.keys,\n        fn: configOrStore.fn,\n        updateFilter: configOrStore.updateFilter,\n      },\n    ],\n    scope,\n  )\n}\n\n/**\nbind event to scope\n\nworks like React.useCallback, but for scopes\n*/\nexport function useEvent(eventObject: any) {\n  return useEventBase(eventObject, getScope(true))\n}\n\n/** useGate wrapper for scopes */\nexport function useGate<Props>(\n  GateComponent: Gate<Props>,\n  props: Props = {} as any,\n) {\n  return useGateBase(GateComponent, props, getScope(true))\n}\n","export const throwError = (message: string) => {\n  throw Error(message)\n}\n","import React from 'react'\n\nexport const useIsomorphicLayoutEffect =\n  typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect\n","import {useEffect} from 'react'\n\nexport const useDeprecate = (\n  cond: boolean,\n  subject: string,\n  useInstead?: string,\n) => {\n  useEffect(() => {\n    if (cond) {\n      console.error(\n        `${subject} is deprecated${\n          useInstead ? `, prefer ${useInstead} instead` : ''\n        }`,\n      )\n    }\n  }, [cond, subject, useInstead])\n}\n","export function forIn<T, Key extends string = string>(\n  obj: Record<Key, T>,\n  cb: (value: T, key: Key) => void,\n) {\n  for (const key in obj) {\n    cb(obj[key], key)\n  }\n}\n\nexport const includes = <T>(list: T[], item: T) => list.includes(item)\n\nexport const removeItem = <T>(list: T[], item: T) => {\n  const pos = list.indexOf(item)\n  if (pos !== -1) {\n    list.splice(pos, 1)\n  }\n}\n\nexport const add = <T>(list: T[], item: T) => list.push(item)\n\nexport function forEach<T>(\n  list: T[],\n  fn: (item: T, index: number, list: T[]) => void,\n): void\nexport function forEach<K, T>(\n  list: Map<K, T>,\n  fn: (item: T, key: K) => void,\n): void\nexport function forEach<T>(list: Set<T>, fn: (item: T) => void): void\nexport function forEach(list: any, fn: Function) {\n  list.forEach(fn)\n}\n","export const deprecate = (method: string, suggestion?: string) => {\n  const suggestionMessage = suggestion ? `, use ${suggestion} instead` : ''\n  console.error(`${method} is deprecated${suggestionMessage}`)\n}\n","console.error('`effector-react/scope` is deprecated. Use `effector-react` directly instead')\nexport * from '../../src/react/ssr'\nexport {Provider} from '../../src/react/scope'\n"],"names":["withDisplayName","name","Component","displayName","useUnitBase","shape","scope","isSingleUnit","is","unit","normShape","throwError","isList","Array","isArray","flagsRef","React","useRef","stale","justSubscribed","eventsShape","storeKeys","storeValues","eventKeys","eventValues","useMemo","current","key","Object","hasOwnProperty","call","event","effect","scopeBind","push","keys","values","stateRef","value","subscribe","useCallback","cb","flags","createWatch","fn","batch","read","state","resultValue","changed","oldVal","oldStoreKeys","oldEventKeys","oldEventValues","scopeChanged","length","i","updatedValue","stateReader","includes","indexOf","useSyncExternalStore","useStoreMapBase","configOrStore","separateFn","defaultValue","store","updateFilter","basicUpdateFilter","valueRef","keysRef","useSyncExternalStoreWithSelector","a","b","isEqual","keysEqual","result","undefined","update","useGateBase","GateComponent","props","open","close","set","ForkedGate","propsRef","count","useIsomorphicLayoutEffect","aKeys","bKeys","shallowCompare","getScope","forceScope","useContext","ScopeContext","processArgsToConfig","args","singleArgument","rawConfig","condition","Error","assert","isObject","isFunction","metadata","or","childConfig","and","unwrappedNestedValue","nested","processCreateGateConfig","hook","universalConfig","arg","nameOrConfig","defaultStateOrConfig","domain","defaultState","mainConfig","maybeConfig","config","isGateConfig","useStore","useDeprecate","useStoreBase","message","window","useLayoutEffect","useEffect","cond","subject","useInstead","console","error","getState","upd","oldValue","createContext","Provider","flattenConfig","part","obj","field","isVoid","forIn","deprecate","method","suggestion","View","createElement","useGateHook","fullName","compositeName","createEvent","sid","status","createStore","Boolean","serialize","on","_","reset","hooks","launch","target","params","createGateImplementation","children","eventObject","events","useEventBase","opts","list","renderItem","getKey","placeholder","Item","shortName","index","keyVal","fnRef","item","memo","keysSelfMemo","listItems","map","from","useListBase"],"mappings":"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"}