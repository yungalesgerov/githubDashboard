{"version":3,"file":"effector.mjs","sources":["effector/collection.ts","effector/throw.ts","effector/region.ts","effector/createNode.ts","effector/tag.ts","effector/kernel.ts","effector/naming.ts","effector/config.ts","effector/subscription.ts","effector/template.ts","effector/createUnit.ts","effector/combine.ts","effector/defer.ts","effector/createEffect.ts","effector/attach.ts","effector/createApi.ts","effector/createDomain.ts","effector/fromObservable.ts","effector/merge.ts","effector/sample.ts","effector/guard.ts","effector/restore.ts","effector/split.ts","effector/fork/allSettled.ts","effector/fork/util.ts","effector/fork/fork.ts","effector/fork/createScope.ts","effector/fork/hydrate.ts","effector/fork/scopeBind.ts","effector/fork/serialize.ts","effector/createWatch.ts","effector/observable.ts","effector/getter.ts","effector/validate.ts","effector/id.ts","effector/own.ts","effector/is.ts","effector/caller.ts","effector/step.ts","effector/stateRef.ts","effector/clearNode.ts","effector/forward.ts","effector/watch.ts"],"sourcesContent":["export function forIn<T, Key extends string = string>(\n  obj: Record<Key, T>,\n  cb: (value: T, key: Key) => void,\n) {\n  for (const key in obj) {\n    cb(obj[key], key)\n  }\n}\n\nexport const includes = <T>(list: T[], item: T) => list.includes(item)\n\nexport const removeItem = <T>(list: T[], item: T) => {\n  const pos = list.indexOf(item)\n  if (pos !== -1) {\n    list.splice(pos, 1)\n  }\n}\n\nexport const add = <T>(list: T[], item: T) => list.push(item)\n\nexport function forEach<T>(\n  list: T[],\n  fn: (item: T, index: number, list: T[]) => void,\n): void\nexport function forEach<K, T>(\n  list: Map<K, T>,\n  fn: (item: T, key: K) => void,\n): void\nexport function forEach<T>(list: Set<T>, fn: (item: T) => void): void\nexport function forEach(list: any, fn: Function) {\n  list.forEach(fn)\n}\n","export function assert(\n  condition: unknown,\n  message: string,\n  errorTitle?: string,\n): asserts condition {\n  if (!condition)\n    throw Error(`${errorTitle ? errorTitle + ': ' : ''}${message}`)\n}\n\nexport const deprecate = (\n  condition: unknown,\n  subject: string,\n  suggestion?: string,\n  errorTitle?: string,\n) =>\n  !condition &&\n  console.error(\n    `${errorTitle ? errorTitle + ': ' : ''}${subject} is deprecated${\n      suggestion ? `, use ${suggestion} instead` : ''\n    }`,\n  )\n","import type {Template} from '../forest/index.h'\nimport type {NodeUnit, Node, ID} from './index.h'\nimport {getParent, getGraph} from './getter'\nimport {createNode} from './createNode'\n\ntype DeclarationSourceReporter = (\n  node: Node | 'region',\n  regionStack: RegionStack | null,\n) => void\n\nlet reporter: DeclarationSourceReporter\n\nexport const setGraphInspector = (fn: DeclarationSourceReporter) => {\n  reporter = fn\n}\n\ntype RegionStack = {\n  id: ID\n  parent: RegionStack | null\n  value: any\n  template: Template | null\n  sidRoot?: string\n  meta:\n    | Record<string, unknown>\n    | {\n        type: 'factory'\n        sid?: string\n        name?: string\n        loc: unknown\n        method?: string\n      }\n}\n\nexport let regionStack: RegionStack | null = null\n\nexport const reportDeclaration = (node: Node | 'region') => {\n  if (reporter) {\n    reporter(node, regionStack)\n  }\n}\n\nexport const readTemplate = (): Template | null =>\n  regionStack && regionStack.template\nexport const readSidRoot = (sid?: string | null) => {\n  if (sid && regionStack && regionStack.sidRoot)\n    sid = `${regionStack.sidRoot}|${sid}`\n  return sid\n}\n\nexport function withRegion<T = void>(unit: NodeUnit, cb: () => T): T {\n  const meta = getGraph(unit).meta || {}\n\n  regionStack = {\n    id: getGraph(unit).id,\n    parent: regionStack,\n    value: unit,\n    template: meta.template || readTemplate(),\n    sidRoot: meta.sidRoot || (regionStack && regionStack.sidRoot),\n    meta: meta,\n  }\n  try {\n    return cb()\n  } finally {\n    reportDeclaration('region')\n    regionStack = getParent(regionStack)\n  }\n}\n\nexport const withFactory = ({\n  sid,\n  name,\n  loc,\n  method,\n  fn,\n}: {\n  sid: string\n  name?: string\n  loc?: any\n  method?: string\n  fn: () => any\n}) => {\n  const factoryRootNode = createNode({\n    meta: {sidRoot: readSidRoot(sid), sid, name, loc, method, type: 'factory'},\n  })\n\n  return withRegion(factoryRootNode, fn)\n}\n","import type {Node, NodeUnit, Cmd} from './index.h'\nimport {getGraph, getOwners, getLinks, getValue} from './getter'\nimport {nextNodeID} from './id'\nimport {CROSSLINK} from './tag'\nimport {regionStack} from './region'\nimport {own} from './own'\nimport {add, forEach} from './collection'\n\nexport const arrifyNodes = (\n  list: NodeUnit | Array<NodeUnit | NodeUnit[]> = [],\n): Node[] => (Array.isArray(list) ? list : [list]).flat().map(getGraph)\n\nexport function createNode({\n  node = [],\n  from,\n  source,\n  parent = from || source,\n  to,\n  target,\n  child = to || target,\n  scope = {},\n  meta = {},\n  family: familyRaw = {type: 'regular'},\n  regional,\n}: {\n  node?: Array<Cmd | false | void | null>\n  from?: NodeUnit | NodeUnit[]\n  source?: NodeUnit | NodeUnit[]\n  parent?: NodeUnit | NodeUnit[]\n  to?: NodeUnit | NodeUnit[]\n  target?: NodeUnit | NodeUnit[]\n  child?: NodeUnit | NodeUnit[]\n  scope?: {[name: string]: any}\n  meta?: {[name: string]: any}\n  family?: {\n    type?: 'regular' | 'crosslink' | 'domain'\n    links?: NodeUnit | NodeUnit[]\n    owners?: NodeUnit | Array<NodeUnit | NodeUnit[]>\n  }\n  regional?: boolean\n} = {}): Node {\n  const sources = arrifyNodes(parent)\n  const links = arrifyNodes(familyRaw.links)\n  const owners = arrifyNodes(familyRaw.owners)\n  const seq: Cmd[] = []\n  forEach(node, item => item && add(seq, item))\n  const result: Node = {\n    id: nextNodeID(),\n    seq,\n    next: arrifyNodes(child),\n    meta,\n    scope,\n    family: {\n      type: familyRaw.type || CROSSLINK,\n      links,\n      owners,\n    },\n  }\n  forEach(links, link => add(getOwners(link), result))\n  forEach(owners, owner => add(getLinks(owner), result))\n  forEach(sources, source => add(source.next, result))\n  if (regional && regionStack) {\n    own(getValue(regionStack), [result])\n  }\n  return result\n}\n","export const STORE = 'store'\nexport const EVENT = 'event'\nexport const EFFECT = 'effect'\nexport const DOMAIN = 'domain'\nexport const SCOPE = 'scope'\nexport const SAMPLER = 'sampler'\nexport const CROSSLINK = 'crosslink'\nexport const MAP = 'map'\nexport const STACK = 'stack'\nexport const VALUE = 'value'\nexport const REG_A = 'a'\n","import type {Leaf} from '../forest/index.h'\n\nimport type {Node, NodeUnit, StateRef, Stack} from './index.h'\nimport {readRef} from './stateRef'\nimport {getForkPage, getGraph, getValue} from './getter'\nimport type {Scope} from './unit.h'\nimport {add, forEach} from './collection'\n\n/** Names of priority groups */\ntype PriorityTag = 'child' | 'pure' | 'read' | 'barrier' | 'sampler' | 'effect'\n\nexport type BarrierPriorityTag = 'read' | 'barrier' | 'sampler' | 'effect'\n\n/**\n * Position in the current branch,\n * including call stack, priority type\n * and index of next step in the executed Node\n */\ntype Layer = {\n  idx: number\n  stack: Stack\n  type: PriorityTag\n  id: number\n}\n\n/** Queue as linked list or skew heap */\ntype QueueItem = {\n  /** node value */\n  v: Layer\n  /** left node. always null in queue but used in skew heap */\n  l: QueueItem | null\n  /** right node */\n  r: QueueItem | null\n}\ntype QueueBucket = {\n  first: QueueItem | null\n  last: QueueItem | null\n  size: number\n}\n\n/** Dedicated local metadata */\ntype Local = {\n  fail: boolean\n  failReason?: unknown\n  scope: {[key: string]: any}\n}\n\nlet heap: QueueItem | null = null\n\nconst merge = (a: QueueItem | null, b: QueueItem | null): QueueItem | null => {\n  if (!a) return b\n  if (!b) return a\n\n  let ret\n  if (\n    /**\n     * if both nodes has the same PriorityType\n     * and first node is created after second one\n     */\n    (a.v.type === b.v.type && a.v.id > b.v.id) ||\n    /**\n     * greater priority mean bucket of first node is executed later\n     * e.g  a: \"sampler\", b: \"barrier\"\n     */\n    getPriority(a.v.type) > getPriority(b.v.type)\n  ) {\n    ret = a\n    a = b\n    b = ret\n  }\n  ret = merge(a.r, b)\n  a.r = a.l\n  a.l = ret\n\n  return a\n}\n\n/** queue buckets for each PriorityType */\nconst queue: QueueBucket[] = []\nlet ix = 0\nwhile (ix < 6) {\n  /**\n   * although \"sampler\" and \"barrier\" are using heap instead of linked list,\n   * their buckets are still useful: they maintains size of heap queue\n   */\n  add(queue, {first: null, last: null, size: 0})\n  ix += 1\n}\n\nconst deleteMin = () => {\n  for (let i = 0; i < 6; i++) {\n    const list = queue[i]\n    if (list.size > 0) {\n      /**\n       * bucket 3 is for \"barrier\" PriorityType (used in combine)\n       * bucket 4 is for \"sampler\" PriorityType (used in sample and guard)\n       */\n      if (i === 3 || i === 4) {\n        list.size -= 1\n        const value = heap!.v\n        heap = merge(heap!.l, heap!.r)\n        return value\n      }\n      if (list.size === 1) {\n        list.last = null\n      }\n      const item = list.first\n      list.first = item!.r\n      list.size -= 1\n      return item!.v\n    }\n  }\n}\nconst pushFirstHeapItem = (\n  type: PriorityTag,\n  page: Leaf | null,\n  node: Node,\n  parent: Stack | null,\n  value: any,\n  scope?: Scope | null | void,\n  meta?: Record<string, any> | void,\n) =>\n  pushHeap(\n    0,\n    {\n      a: null,\n      b: null,\n      node,\n      parent,\n      value,\n      page,\n      scope,\n      meta,\n    },\n    type,\n    0,\n  )\nconst pushHeap = (idx: number, stack: Stack, type: PriorityTag, id: number) => {\n  const priority = getPriority(type)\n  const bucket: QueueBucket = queue[priority]\n  const item: QueueItem = {\n    v: {idx, stack, type, id},\n    l: null,\n    r: null,\n  }\n  /**\n   * bucket 3 is for \"barrier\" PriorityType (used in combine)\n   * bucket 4 is for \"sampler\" PriorityType (used in sample and guard)\n   */\n  if (priority === 3 || priority === 4) {\n    heap = merge(heap, item)\n  } else {\n    if (bucket.size === 0) {\n      bucket.first = item\n    } else {\n      bucket.last!.r = item\n    }\n    bucket.last = item\n  }\n  bucket.size += 1\n}\n\nconst getPriority = (t: PriorityTag) => {\n  switch (t) {\n    case 'child':\n      return 0\n    case 'pure':\n      return 1\n    case 'read':\n      return 2\n    case 'barrier':\n      return 3\n    case 'sampler':\n      return 4\n    case 'effect':\n      return 5\n    default:\n      return -1\n  }\n}\n\nconst barriers = new Set<string | number>()\n\nlet isRoot = true\nexport let isWatch = false\nexport let isPure = false\nexport let currentPage: Leaf | null = null\nexport let forkPage: Scope | void | null\nexport const setForkPage = (newForkPage: Scope | void | null) => {\n  forkPage = newForkPage\n}\nexport const setCurrentPage = (newPage: Leaf | null) => {\n  currentPage = newPage\n}\n\nconst getPageForRef = (page: Leaf | null, id: string) => {\n  if (page) {\n    while (page && !page.reg[id]) {\n      page = page.parent\n    }\n    if (page) return page\n  }\n  return null\n}\nexport const getPageRef = (\n  page: Leaf | null,\n  forkPage: Scope | null | void,\n  ref: StateRef,\n  isGetState: boolean,\n) => {\n  const pageForRef = getPageForRef(page, ref.id)\n  if (pageForRef) return pageForRef.reg[ref.id]\n  if (forkPage) {\n    initRefInScope(forkPage!, ref, isGetState)\n    return forkPage.reg[ref.id]\n  }\n  return ref\n}\n\n/** Introspection api internals */\ntype Inspector = (stack: Stack, local: Local) => void\nlet inspector: Inspector\nexport const setInspector = (newInspector: Inspector) => {\n  inspector = newInspector\n}\n\nexport function launch(config: {\n  target: NodeUnit | NodeUnit[]\n  params?: any\n  defer?: boolean\n  page?: Leaf | void | null\n  scope?: Scope | void | null\n  stack?: Stack | void\n  meta?: Record<string, any> | void\n}): void\nexport function launch(unit: NodeUnit, payload?: any, upsert?: boolean): void\nexport function launch(unit: any, payload?: any, upsert?: boolean) {\n  let pageForLaunch = currentPage\n  let stackForLaunch = null\n  let forkPageForLaunch = forkPage\n  let meta: Record<string, any> | void\n  if (unit.target) {\n    payload = unit.params\n    upsert = unit.defer\n    meta = unit.meta\n    pageForLaunch = 'page' in unit ? unit.page : pageForLaunch\n    if (unit.stack) stackForLaunch = unit.stack\n    forkPageForLaunch = getForkPage(unit) || forkPageForLaunch\n    unit = unit.target\n  }\n  if (forkPageForLaunch && forkPage && forkPageForLaunch !== forkPage) {\n    forkPage = null\n  }\n  if (Array.isArray(unit)) {\n    for (let i = 0; i < unit.length; i++) {\n      pushFirstHeapItem(\n        'pure',\n        pageForLaunch,\n        getGraph(unit[i]),\n        stackForLaunch,\n        payload[i],\n        forkPageForLaunch,\n        meta,\n      )\n    }\n  } else {\n    pushFirstHeapItem(\n      'pure',\n      pageForLaunch,\n      getGraph(unit),\n      stackForLaunch,\n      payload,\n      forkPageForLaunch,\n      meta,\n    )\n  }\n  if (upsert && !isRoot) return\n  /** main execution code */\n  const lastStartedState = {\n    isRoot,\n    currentPage,\n    scope: forkPage,\n    isWatch,\n    isPure,\n  }\n  isRoot = false\n  let stop: boolean\n  let skip: boolean\n  let node: Node\n  let value: Layer | undefined\n  let page: Leaf | null\n  let reg: Record<string, StateRef> | void\n  kernelLoop: while ((value = deleteMin())) {\n    const {idx, stack, type} = value\n    node = stack.node\n    currentPage = page = stack.page\n    forkPage = getForkPage(stack)\n    if (page) reg = page.reg\n    else if (forkPage) reg = forkPage.reg\n    // reg = (page ? page : forkPage ? forkPage : node).reg\n    const hasPageReg = !!page\n    const hasScopeReg = !!forkPage\n    const local: Local = {\n      fail: false,\n      scope: node.scope,\n    }\n    stop = skip = false\n    for (let stepn = idx; stepn < node.seq.length && !stop; stepn++) {\n      const step = node.seq[stepn]\n      if (step.order) {\n        const {priority, barrierID} = step.order\n        const id = barrierID\n          ? page\n            ? `${page.fullID}_${barrierID}`\n            : barrierID\n          : 0\n        if (stepn !== idx || type !== priority) {\n          if (barrierID) {\n            if (!barriers.has(id)) {\n              barriers.add(id)\n              pushHeap(stepn, stack, priority, barrierID)\n            }\n          } else {\n            pushHeap(stepn, stack, priority, 0)\n          }\n          continue kernelLoop\n        }\n        barrierID && barriers.delete(id)\n      }\n      switch (step.type) {\n        case 'mov': {\n          const data = step.data\n          let value\n          //prettier-ignore\n          switch (data.from) {\n            case 'stack': value = getValue(stack); break\n            case 'a': /** fall-through case */\n            case 'b':\n              value = stack[data.from]\n              break\n            case 'value': value = data.store; break\n            case 'store':\n              if (reg && !reg[data.store.id]) {\n                // if (!page.parent) {\n                if (hasPageReg) {\n                  const pageForRef = getPageForRef(page, data.store.id)\n                  stack.page = page = pageForRef\n                  if (pageForRef) {\n                    reg = pageForRef.reg\n                  } else if (hasScopeReg) {\n                    initRefInScope(forkPage!, data.store, false, true, data.softRead)\n                    reg = forkPage!.reg\n                  } else {\n                    reg = undefined //node.reg\n                  }\n                } else if (hasScopeReg) {\n                  /** StateRef in Scope.reg created only when needed */\n                  initRefInScope(forkPage!, data.store, false, true, data.softRead)\n                } else {\n                  // console.error('should not happen')\n                  /** StateRef should exists at least in Node itself, but it is not found */\n                }\n                // }\n              }\n              // value = getPageRef(page, forkPage, data.store.id, false).current\n              value = readRef(reg ? reg[data.store.id] || data.store : data.store)\n              break\n          }\n          //prettier-ignore\n          switch (data.to) {\n            case 'stack': stack.value = value; break\n            case 'a': /** fall-through case */\n            case 'b':\n              stack[data.to] = value\n              break\n            case 'store':\n              getPageRef(page, forkPage, data.target, false).current = value\n              break\n          }\n          break\n        }\n        case 'compute':\n          const data = step.data\n          if (data.fn) {\n            isWatch = node.meta.op === 'watch'\n            isPure = data.pure\n            const computationResult = data.safe\n              ? (0 as any, data.fn)(getValue(stack), local.scope, stack)\n              : tryRun(local, data.fn, stack)\n            if (data.filter) {\n              /**\n               * handled edge case: if step.fn will throw,\n               * tryRun will return null\n               * thereby forcing that branch to stop\n               */\n              skip = !computationResult\n            } else {\n              stack.value = computationResult\n            }\n            isWatch = lastStartedState.isWatch\n            isPure = lastStartedState.isPure\n          }\n          break\n      }\n      stop = local.fail || skip\n    }\n    if (inspector) {\n      inspector(stack, local)\n    }\n    if (!stop) {\n      const finalValue = getValue(stack)\n      const forkPage = getForkPage(stack)\n      forEach(node.next, nextNode => {\n        pushFirstHeapItem('child', page, nextNode, stack, finalValue, forkPage)\n      })\n      if (forkPage) {\n        if (node.meta.needFxCounter)\n          pushFirstHeapItem(\n            'child',\n            page,\n            forkPage.fxCount,\n            stack,\n            finalValue,\n            forkPage,\n          )\n        if (node.meta.storeChange)\n          pushFirstHeapItem(\n            'child',\n            page,\n            forkPage.storeChange,\n            stack,\n            finalValue,\n            forkPage,\n          )\n        if (node.meta.warnSerialize)\n          pushFirstHeapItem(\n            'child',\n            page,\n            forkPage.warnSerializeNode,\n            stack,\n            finalValue,\n            forkPage,\n          )\n        const additionalLinks = forkPage.additionalLinks[node.id]\n        if (additionalLinks) {\n          forEach(additionalLinks, nextNode => {\n            pushFirstHeapItem(\n              'child',\n              page,\n              nextNode,\n              stack,\n              finalValue,\n              forkPage,\n            )\n          })\n        }\n      }\n    }\n  }\n  isRoot = lastStartedState.isRoot\n  currentPage = lastStartedState.currentPage\n  forkPage = getForkPage(lastStartedState)\n}\n\nconst noopParser = (x: any) => x\n\nexport const initRefInScope = (\n  scope: Scope,\n  sourceRef: StateRef,\n  isGetState?: boolean,\n  isKernelCall?: boolean,\n  softRead?: boolean,\n) => {\n  const refsMap = scope.reg\n  if (refsMap[sourceRef.id]) return\n  const sid = sourceRef.sid\n  const ref: StateRef = {\n    id: sourceRef.id,\n    current: sourceRef.initial!,\n    meta: sourceRef.meta,\n  }\n\n  if (ref.id in scope.values.idMap) {\n    ref.current = scope.values.idMap[ref.id]\n  } else if (sid && sid in scope.values.sidMap && !(sid in scope.sidIdMap)) {\n    const serialize = sourceRef?.meta?.serialize\n    const parser =\n      scope.fromSerialize && serialize !== 'ignore'\n        ? serialize?.read || noopParser\n        : noopParser\n    ref.current = parser(scope.values.sidMap[sid])\n  } else {\n    if (sourceRef.before && !softRead) {\n      let isFresh = false\n      const needToAssign = isGetState || !sourceRef.noInit || isKernelCall\n      forEach(sourceRef.before, cmd => {\n        switch (cmd.type) {\n          case 'map': {\n            const from = cmd.from\n            if (from || cmd.fn) {\n              if (from) initRefInScope(scope, from, isGetState, isKernelCall)\n              if (needToAssign) {\n                const value = from && refsMap[from.id].current\n                ref.current = cmd.fn ? cmd.fn(value) : value\n              }\n            }\n            break\n          }\n          case 'field': {\n            initRefInScope(scope, cmd.from, isGetState, isKernelCall)\n            if (!isFresh) {\n              isFresh = true\n              if (Array.isArray(ref.current)) {\n                ref.current = [...ref.current]\n              } else {\n                ref.current = {...ref.current}\n              }\n            }\n            if (needToAssign) {\n              const from = refsMap[cmd.from.id]\n              ref.current[cmd.field] = refsMap[from.id].current\n            }\n            break\n          }\n          // case 'closure':\n          //   break\n        }\n      })\n    }\n  }\n  if (sid) scope.sidIdMap[sid] = sourceRef.id\n  refsMap[sourceRef.id] = ref\n}\n\n/** try catch for external functions */\nconst tryRun = (local: Local, fn: Function, stack: Stack) => {\n  try {\n    return fn(getValue(stack), local.scope, stack)\n  } catch (err) {\n    console.error(err)\n    local.fail = true\n    local.failReason = err\n  }\n}\n","import type {Store, CommonUnit, Domain} from './unit.h'\nimport {is} from './is'\nimport {getParent, getCompositeName} from './getter'\nimport {forIn} from './collection'\n\nexport function unitObjectName(objOrArr: any, method: string = 'combine') {\n  let name = method + '('\n  let comma = ''\n  let i = 0\n  forIn(objOrArr, unit => {\n    /* inlined max object names constant */\n    if (i < 25) {\n      if (unit != null) {\n        name += comma\n        name += is.unit(unit)\n          ? getCompositeName(unit as CommonUnit | Domain).fullName\n          : (unit as any).toString()\n      }\n      i += 1\n      comma = ', '\n    }\n  })\n  return name + ')'\n}\n\nexport function setStoreName<State>(store: Store<State>, rawName: string) {\n  store.shortName = rawName\n  Object.assign(getCompositeName(store), createName(rawName, getParent(store)))\n}\n\nexport type CompositeName = {\n  shortName: string\n  fullName: string\n  path: string[]\n}\n\nexport function createName(name: string, parent?: Domain): CompositeName {\n  let path: string[]\n  let fullName\n  const shortName = name\n  if (!parent) {\n    path = name.length === 0 ? [] : [name]\n    fullName = name\n  } else {\n    const composite = getCompositeName(parent)\n    if (name.length === 0) {\n      path = composite.path\n      fullName = composite.fullName\n    } else {\n      path = composite.path.concat([name])\n      fullName =\n        composite.fullName.length === 0\n          ? name\n          : '' + composite.fullName + '/' + name\n    }\n  }\n  return {shortName, fullName, path}\n}\n\nexport function generateErrorTitle(method: string, metadata: any) {\n  if (!metadata) return method\n  if (!metadata.name && !metadata.named && !metadata.loc) return method\n  let result = `[${method}]`\n  const name = metadata.named || metadata.name\n  if (name) {\n    result += ` unit '${name}'`\n  }\n  const loc = metadata.loc\n  if (!name && loc) {\n    result += ` (${loc.file}:${loc.line}:${loc.column})`\n  }\n  return result\n}\n","import {forIn} from './collection'\nimport {assertObject, isObject, isVoid} from './is'\n\nexport function processArgsToConfig(\n  arg: any,\n  singleArgument: true,\n): [any, any | void]\nexport function processArgsToConfig(args: any[]): [any[], any | void]\nexport function processArgsToConfig(\n  args: any[],\n  singleArgument?: boolean,\n): [any[], any | void] {\n  const rawConfig = singleArgument ? args : args[0]\n  assertObject(rawConfig)\n  let metadata = rawConfig.or\n  const childConfig = rawConfig.and\n  if (childConfig) {\n    const unwrappedNestedValue = singleArgument ? childConfig : childConfig[0]\n    /**\n     * if there is no \"and\" field then we reached the leaf of the tree\n     * and this is an original user-defined argument\n     *\n     * note that in this case we're returning all arguments, not the only one been unwrapped\n     **/\n    if (!isObject(unwrappedNestedValue) || !('and' in unwrappedNestedValue)) {\n      args = childConfig\n    } else {\n      //@ts-expect-error\n      const nested = processArgsToConfig(childConfig, singleArgument)\n\n      args = nested[0]\n      metadata = {...metadata, ...nested[1]}\n    }\n  }\n  return [args, metadata]\n}\n\n/**\nprocessed fields:\n\n'name',\n'sid',\n'loc',\n'handler',\n'updateFilter',\n'parent',\n'serialize',\n'named',\n'derived',\n*/\nexport const flattenConfig = (part: any, config: Record<string, any> = {}) => {\n  if (isObject(part)) {\n    flattenConfig(part.or, config)\n    forIn(part, (value, field) => {\n      if (!isVoid(value) && field !== 'or' && field !== 'and') {\n        config[field] = value\n      }\n    })\n    flattenConfig(part.and, config)\n  }\n  return config\n}\n","import type {Subscription, NodeUnit} from './index.h'\nimport {clearNode} from './clearNode'\n\nexport const createSubscription = (node: NodeUnit): Subscription =>\n  addUnsubscribe(() => clearNode(node))\n\nexport function addUnsubscribe(callback: () => void): Subscription {\n  const subscription: Subscription = () => callback()\n  subscription.unsubscribe = () => callback()\n\n  return subscription\n}\n","import {readTemplate} from './region'\nimport type {Template, TemplateHandlers} from '../forest/index.h'\n\nexport function applyTemplate<K extends keyof TemplateHandlers>(\n  method: K,\n  ...args: Parameters<TemplateHandlers[K]> extends [Template, ...infer Args]\n    ? Args\n    : never\n): ReturnType<TemplateHandlers[K]> | void {\n  const template = readTemplate()\n  if (template) {\n    const fn = template.handlers[method]\n    // @ts-expect-error\n    if (fn) return fn(template, ...args)\n  }\n}\n","import type {Template} from '../forest/index.h'\nimport type {Store, Event, CommonUnit, Effect, Domain} from './unit.h'\nimport type {Subscriber, Config, Cmd, Kind} from './index.h'\n\nimport {observableSymbol} from './observable'\n\nimport {\n  is,\n  isObject,\n  isFunction,\n  assertObject,\n  assertNodeSet,\n  isVoid,\n} from './is'\nimport {calc, mov, read, userFnCall} from './step'\nimport {createStateRef, readRef, addRefOp} from './stateRef'\nimport {nextUnitID} from './id'\nimport {callStackAReg, callARegStack, callStack} from './caller'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {\n  launch,\n  currentPage,\n  forkPage,\n  setCurrentPage,\n  initRefInScope,\n  isPure,\n} from './kernel'\n\nimport {createName, generateErrorTitle} from './naming'\nimport {createLinkNode} from './forward'\nimport {watchUnit} from './watch'\nimport {createSubscription} from './subscription'\nimport {readTemplate, readSidRoot, reportDeclaration} from './region'\nimport {\n  getSubscribers,\n  getStoreState,\n  getGraph,\n  getParent,\n  setMeta,\n  getMeta,\n} from './getter'\nimport {assert, deprecate} from './throw'\nimport {DOMAIN, STORE, EVENT, MAP, STACK, REG_A} from './tag'\nimport {applyTemplate} from './template'\nimport {forEach} from './collection'\nimport {flattenConfig} from './config'\n\nexport const applyParentHook = (\n  source: CommonUnit,\n  target: CommonUnit,\n  hookType: 'event' | 'effect' = EVENT,\n) => {\n  if (getParent(source)) getParent(source).hooks[hookType](target)\n}\n\nexport const initUnit = (kind: Kind, unit: any, rawConfig: any) => {\n  const config = flattenConfig(rawConfig)\n  const isDomain = kind === DOMAIN\n  const id = nextUnitID()\n  const {sid = null, named = null, domain = null, parent = domain} = config\n  const name = named ? named : config.name || (isDomain ? '' : id)\n  const compositeName = createName(name, parent)\n  const meta: Record<string, any> = {\n    op: (unit.kind = kind),\n    name: (unit.shortName = name),\n    sid: (unit.sid = readSidRoot(sid)),\n    named,\n    unitId: (unit.id = id),\n    serialize: config.serialize,\n    derived: config.derived,\n    config,\n  }\n  unit.targetable = !config.derived\n  unit.parent = parent\n  unit.compositeName = compositeName\n  unit.defaultConfig = config\n  unit.getType = () => {\n    deprecate(false, 'getType', 'compositeName.fullName')\n    return compositeName.fullName\n  }\n  if (!isDomain) {\n    unit.subscribe = (observer: Subscriber<any>) => {\n      assertObject(observer)\n      return unit.watch(\n        isFunction(observer)\n          ? observer\n          : (upd: any) => observer.next && observer.next(upd),\n      )\n    }\n    unit[observableSymbol] = () => unit\n    const template = readTemplate()\n    if (template) meta.nativeTemplate = template\n  }\n  return meta\n}\nexport const createNamedEvent = (named: string) => createEvent({named})\n\nconst deriveEvent = (\n  event: Event<any>,\n  op: 'map' | 'filterMap' | 'filter',\n  fn: Function,\n  node: Cmd[],\n) => {\n  let config\n  if (isObject(fn)) {\n    config = fn\n    fn = (fn as unknown as {fn: Function}).fn\n  }\n  const mapped = createEvent({\n    name: `${event.shortName} → *`,\n    derived: true,\n    and: config,\n  })\n  createLinkNode(event, mapped, node, op, fn)\n  return mapped\n}\n\nfunction callCreate<T>(\n  unit: Event<T> | Effect<T, any, any>,\n  template: Template | null,\n  payload: T,\n  args: any[],\n) {\n  const oldPage = currentPage\n  let page = null\n  if (template) {\n    page = currentPage\n    while (page && page.template !== template) {\n      page = getParent(page)\n    }\n  }\n  setCurrentPage(page)\n  const result = unit.create(payload, args)\n  setCurrentPage(oldPage)\n  return result\n}\n\nexport function createEvent<Payload = any>(\n  nameOrConfig?: any,\n  maybeConfig?: any,\n): Event<Payload> {\n  const config = flattenConfig({\n    or: maybeConfig,\n    and: typeof nameOrConfig === 'string' ? {name: nameOrConfig} : nameOrConfig,\n  }) as any\n  const errorTitle = generateErrorTitle('event', config)\n  const event = ((payload: Payload, ...args: unknown[]) => {\n    assert(\n      !getMeta(event, 'derived'),\n      'call of derived event is not supported, use createEvent instead',\n      errorTitle,\n    )\n    assert(\n      !isPure,\n      'unit call from pure function is not supported, use operators like sample instead',\n      errorTitle,\n    )\n    if (currentPage) {\n      return callCreate(event, template, payload, args)\n    }\n    return event.create(payload, args)\n  }) as Event<Payload>\n  const template = readTemplate()\n  const finalEvent = Object.assign(event, {\n    graphite: createNode({\n      meta: initUnit(config.actualOp || EVENT, event, config),\n      regional: true,\n    }),\n    create(params: Payload, _: any[]) {\n      launch({target: event, params, scope: forkPage!})\n      return params\n    },\n    watch: (fn: (payload: Payload) => any) => watchUnit(event, fn),\n    map: (fn: Function) => deriveEvent(event, MAP, fn, [userFnCall()]),\n    filter: (fn: {fn: Function}) =>\n      //@ts-expect-error\n      deriveEvent(event, 'filter', fn.fn ? fn : fn.fn, [\n        userFnCall(callStack, true),\n      ]),\n    filterMap: (fn: Function) =>\n      deriveEvent(event, 'filterMap', fn, [\n        userFnCall(),\n        calc(value => !isVoid(value), true),\n      ]),\n    prepend(fn: Function) {\n      assert(\n        // @ts-expect-error\n        event.targetable,\n        '.prepend of derived event is not supported, call source event instead',\n        errorTitle,\n      )\n      const contramapped: Event<any> = createEvent('* → ' + event.shortName, {\n        parent: getParent(event),\n      })\n      applyTemplate('eventPrepend', getGraph(contramapped))\n      createLinkNode(contramapped, event, [userFnCall()], 'prepend', fn)\n      applyParentHook(event, contramapped)\n      return contramapped\n    },\n  })\n  if (config?.domain) {\n    config.domain.hooks.event(finalEvent)\n  }\n  setMeta(finalEvent, 'id', finalEvent.graphite.id)\n  reportDeclaration(finalEvent.graphite)\n  return finalEvent\n}\nfunction on<State>(\n  store: Store<State>,\n  methodName: string,\n  nodeSet: CommonUnit | CommonUnit[],\n  fn: Function,\n  errorTitle: string,\n) {\n  assertNodeSet(nodeSet, `${errorTitle} ${methodName}`, 'first argument')\n  assert(isFunction(fn), 'second argument should be a function', errorTitle)\n  deprecate(\n    !getMeta(store, 'derived'),\n    `${methodName} in derived store`,\n    `${methodName} in store created via createStore`,\n    errorTitle,\n  )\n  forEach(Array.isArray(nodeSet) ? nodeSet : [nodeSet], trigger => {\n    store.off(trigger)\n    getSubscribers(store).set(\n      trigger,\n      createSubscription(updateStore(trigger, store, 'on', callARegStack, fn)),\n    )\n  })\n  return store\n}\n\nexport const requireExplicitSkipVoidMessage =\n  'undefined is used to skip updates. To allow undefined as a value provide explicit { skipVoid: false } option'\n\nexport function createStore<State>(\n  defaultState: State,\n  props?: Config,\n): Store<State> {\n  const config = flattenConfig(props)\n  const plainState = createStateRef(defaultState)\n  const errorTitle = generateErrorTitle('store', config)\n  const updates = createEvent({named: 'updates', derived: true})\n  applyTemplate('storeBase', plainState)\n  const plainStateId = plainState.id\n\n  // skipVoid deprecation rules\n  const explicitSkipVoid = 'skipVoid' in config\n  const voidValueAllowed = explicitSkipVoid && !config.skipVoid\n  const skipVoidTrueSet = explicitSkipVoid && config.skipVoid\n\n  deprecate(!skipVoidTrueSet, '{skipVoid: true}', 'updateFilter', errorTitle)\n\n  const store = {\n    subscribers: new Map(),\n    updates,\n    defaultState,\n    stateRef: plainState,\n    getState() {\n      let targetRef = plainState\n      let reachedPage\n      if (currentPage) {\n        let page = currentPage\n        while (page && !page.reg[plainStateId]) {\n          page = getParent(page)\n        }\n        if (page) reachedPage = page\n      }\n      if (!reachedPage && forkPage) {\n        initRefInScope(forkPage, plainState, true)\n        reachedPage = forkPage\n      }\n      if (reachedPage) targetRef = reachedPage.reg[plainStateId]\n      return readRef(targetRef)\n    },\n    setState: (state: State) =>\n      launch({\n        target: store,\n        params: state,\n        defer: true,\n        scope: forkPage!,\n      }),\n    reset(...units: CommonUnit[]) {\n      assert(\n        // @ts-expect-error\n        store.targetable,\n        '.reset of derived store is not supported',\n        errorTitle,\n      )\n      forEach(units, unit =>\n        on(store, '.reset', unit, () => store.defaultState, errorTitle),\n      )\n      return store\n    },\n    on(nodeSet: CommonUnit | CommonUnit[], fn: Function) {\n      assert(\n        // @ts-expect-error\n        store.targetable,\n        '.on of derived store is not supported',\n        errorTitle,\n      )\n      return on(store, '.on', nodeSet, fn, errorTitle)\n    },\n    off(unit: CommonUnit) {\n      const currentSubscription = getSubscribers(store).get(unit)\n      if (currentSubscription) {\n        currentSubscription()\n        getSubscribers(store).delete(unit)\n      }\n      return store\n    },\n    map(fn: (value: any) => any, outerConfig: Config) {\n      let mapConfig: Config | undefined\n      if (isObject(fn)) {\n        mapConfig = fn as any\n        fn = (fn as unknown as {fn: (value: any) => any}).fn\n      }\n      let lastResult\n      const storeState = store.getState()\n      const parentStateVoid = isVoid(storeState)\n      const template = readTemplate()\n      if (template) {\n        lastResult = null\n      } else if (!parentStateVoid || (parentStateVoid && voidValueAllowed)) {\n        lastResult = fn(storeState)\n      }\n\n      const innerStore: Store<any> = createStore(lastResult, {\n        name: `${store.shortName} → *`,\n        derived: true,\n        ...outerConfig,\n        and: mapConfig,\n      })\n      const linkNode = updateStore(store, innerStore, MAP, callStack, fn)\n      addRefOp(getStoreState(innerStore), {\n        type: MAP,\n        fn,\n        from: plainState,\n      })\n      getStoreState(innerStore).noInit = true\n      applyTemplate('storeMap', plainState, linkNode)\n      return innerStore\n    },\n    watch(eventOrFn: any, fn?: Function) {\n      deprecate(!fn, 'watch second argument', 'sample', errorTitle)\n      if (!fn || !is.unit(eventOrFn)) {\n        const subscription = watchUnit(store, eventOrFn)\n        if (!applyTemplate('storeWatch', plainState, eventOrFn)) {\n          eventOrFn(store.getState())\n        }\n        return subscription\n      }\n      assert(isFunction(fn), 'second argument should be a function', errorTitle)\n      return (eventOrFn as CommonUnit).watch((payload: any) =>\n        fn(store.getState(), payload),\n      )\n    },\n  } as unknown as Store<State>\n  const meta = initUnit(STORE, store, config)\n  const updateFilter = store.defaultConfig.updateFilter\n  store.graphite = createNode({\n    scope: {state: plainState, fn: updateFilter},\n    node: [\n      calc((upd, _, stack) => {\n        if (stack.scope && !stack.scope.reg[plainState.id]) {\n          stack.b = true\n        }\n        return upd\n      }),\n      read(plainState),\n      calc((upd, _, {a, b}) => {\n        const isVoidUpdate = isVoid(upd)\n\n        if (isVoidUpdate && !explicitSkipVoid) {\n          console.error(`${errorTitle}: ${requireExplicitSkipVoidMessage}`)\n        }\n\n        return (\n          ((isVoidUpdate && voidValueAllowed) || !isVoidUpdate) &&\n          (upd !== a || b)\n        )\n      }, true),\n      updateFilter && userFnCall(callStackAReg, true),\n      mov({from: STACK, target: plainState}),\n    ],\n    child: updates,\n    meta: {\n      ...meta,\n      defaultState,\n    },\n    regional: true,\n  })\n  setMeta(store, 'id', store.graphite.id)\n  setMeta(store, 'rootStateRefId', plainStateId)\n  const serializeMeta = getMeta(store, 'serialize')\n  const derived = getMeta(store, 'derived')\n  const ignored = serializeMeta === 'ignore'\n  const sid: string | null = getMeta(store, 'sid')\n  if (sid) {\n    setMeta(store, 'storeChange', true)\n    plainState.sid = sid\n  }\n  if (!sid && !ignored && !derived) {\n    setMeta(store, 'warnSerialize', true)\n  }\n  const isVoidDefaultState = isVoid(defaultState)\n  const canVoid = isVoidDefaultState && voidValueAllowed\n  assert(\n    derived || !isVoidDefaultState || canVoid,\n    requireExplicitSkipVoidMessage,\n    errorTitle,\n  )\n  if (derived && isVoidDefaultState && !explicitSkipVoid) {\n    console.error(`${errorTitle}: ${requireExplicitSkipVoidMessage}`)\n  }\n  own(store, [updates])\n  if (config?.domain) {\n    config.domain.hooks.store(store)\n  }\n\n  if (!derived) {\n    store.reinit = createEvent<void>({\n      named: 'reinit',\n    })\n    store.reset(store.reinit)\n  }\n\n  plainState.meta = store.graphite.meta\n\n  reportDeclaration(store.graphite)\n\n  return store\n}\n\nconst updateStore = (\n  from: CommonUnit,\n  store: Store<any>,\n  op: string,\n  caller: typeof callStackAReg,\n  fn: Function,\n) => {\n  const storeRef = getStoreState(store)\n  const reader = mov({\n    store: storeRef,\n    to: REG_A,\n    priority: 'read',\n  })\n  /**\n   * Store reading is not needed for store.map anymore\n   * but there is a fine tuning of \"wire lengths\"\n   * lack of which leads to a lot of reordering and retriggering issues\n   **/\n  if (op === MAP) reader.data.softRead = true\n  const node = [reader, userFnCall(caller)]\n  applyTemplate(\n    'storeOnMap',\n    storeRef,\n    node,\n    is.store(from) && getStoreState(from),\n  )\n  return createLinkNode(from, store, node, op, fn)\n}\n","import type {Store} from './unit.h'\nimport {createStore, requireExplicitSkipVoidMessage} from './createUnit'\nimport {createStateRef, addRefOp} from './stateRef'\nimport {mov, calc, read, userFnCall} from './step'\nimport {processArgsToConfig} from './config'\nimport {getStoreState, setMeta} from './getter'\nimport {is, isFunction, isObject, isVoid} from './is'\nimport {generateErrorTitle, unitObjectName} from './naming'\nimport {createLinkNode} from './forward'\nimport {assert, deprecate} from './throw'\nimport {readTemplate} from './region'\nimport {forIn} from './collection'\nimport {MAP, REG_A, VALUE} from './tag'\nimport {applyTemplate} from './template'\nimport type {Config} from './index.h'\n\nexport function combine(...args: any[]): Store<any> {\n  let handler\n  let stores\n  let config\n  ;[args, config] = processArgsToConfig(args)\n  const errorTitle = generateErrorTitle('combine', config)\n  // skipVoid support, to be removed in effector 24\n  const maybeExtConfig = args[args.length - 1]\n  /**\n   * if there only one argument then it's a store or object with stores\n   * else if last argument is a store, then its `combine($foo, $bar)`\n   * else if last argument is not an object, then it's a handler\n   * else it's a config object\n   */\n  const isExtendedConfig =\n    args.length > 1 && !is.store(maybeExtConfig) && isObject(maybeExtConfig)\n  const extConfig = isExtendedConfig && maybeExtConfig\n  const rawHandler = isExtendedConfig ? args[args.length - 2] : maybeExtConfig\n  if (isFunction(rawHandler)) {\n    stores = args.slice(0, isExtendedConfig ? -2 : -1)\n    handler = rawHandler\n  } else {\n    stores = args\n  }\n\n  let structStoreShape\n  let shapeReady\n  if (stores.length === 1) {\n    const obj = stores[0]\n    /*\n      without edge case combine(Color, (Color) => '~')\n      */\n    if (!is.store(obj)) {\n      /*\n      case combine([R,G,B], ([R,G,B]) => '~')\n      case combine({R,G,B}, ({R,G,B}) => '~')\n\n      edge case combine([Color], ([Color]) => '~')\n      edge case combine({Color}, ({Color}) => '~')\n\n      edge case combine([R,G,B])\n      edge case combine({R,G,B})\n\n      edge case combine([Color])\n      edge case combine({Color})\n      */\n      structStoreShape = obj\n      shapeReady = true\n    }\n  }\n  let noArraySpread: boolean | undefined\n  if (!shapeReady) {\n    /*\n    case combine(R,G,B, (R,G,B) => '~')\n    */\n    structStoreShape = stores\n    /*\n    without edge case combine(R,G,B)\n    without edge case combine(Color)\n    */\n    if (handler) {\n      noArraySpread = true\n      const fn = handler\n      handler = (list: any[]) => fn(...list)\n    }\n  }\n  assert(isObject(structStoreShape), `${errorTitle}: shape should be an object`)\n  return storeCombination(\n    Array.isArray(structStoreShape),\n    !noArraySpread,\n    structStoreShape,\n    config,\n    handler,\n    extConfig,\n  )\n}\n\nconst storeCombination = (\n  isArray: boolean,\n  needSpread: boolean,\n  obj: any,\n  config?: Config,\n  fn?: (upd: any) => any,\n  extConfig?: false | {skipVoid?: boolean},\n) => {\n  const errorTitle = generateErrorTitle('combine', config)\n  const clone = isArray ? (list: any) => [...list] : (obj: any) => ({...obj})\n  const defaultState: Record<string, any> = isArray ? [] : {}\n\n  const stateNew = clone(defaultState)\n  const rawShape = createStateRef(stateNew)\n  const isFresh = createStateRef(true)\n  rawShape.type = isArray ? 'list' : 'shape'\n  rawShape.noInit = true\n  applyTemplate('combineBase', rawShape, isFresh)\n  const store = createStore(stateNew, {\n    name: unitObjectName(obj),\n    derived: true,\n    ...extConfig,\n    and: config,\n  })\n  const storeStateRef = getStoreState(store)\n  storeStateRef.noInit = true\n  setMeta(store, 'isCombine', true)\n  const rawShapeReader = read(rawShape)\n  /**\n   * usual ref reading has very high priority, which leads to data races\n   * ref reading for combine should have same \"barrier\" priority but without batching\n   * (thats why order has no \"barrierID\" field, which assume batching)\n   **/\n  rawShapeReader.order = {priority: 'barrier'}\n  /**\n   * Soft store reading is required for\n   * setting target store as inited in scope\n   * for preventing retriggering issues\n   **/\n  const softReader = mov({\n    store: storeStateRef,\n    to: 'b',\n    priority: 'read',\n  })\n  softReader.data.softRead = true\n  const node = [\n    calc((upd, _, stack) => {\n      if (stack.scope && !stack.scope.reg[rawShape.id]) {\n        stack.c = true\n      }\n      return upd\n    }),\n    rawShapeReader,\n    mov({store: isFresh, to: 'b'}),\n    calc((upd, {key}, reg) => {\n      if (reg.c || upd !== reg.a[key]) {\n        if (needSpread && reg.b) {\n          reg.a = clone(reg.a)\n        }\n        reg.a[key] = upd\n        return true\n      }\n    }, true),\n    mov({from: REG_A, target: rawShape}),\n    mov({from: VALUE, store: false, target: isFresh}),\n    mov({\n      from: VALUE,\n      store: true,\n      target: isFresh,\n      priority: 'barrier',\n      batch: true,\n    }),\n    /**\n     * `read` with `sampler` priority is used to prevent cases,\n     *  where `combine` triggers are duplicated\n     *\n     *  basically, this makes `sample` and `combine` priorities equal\n     */\n    read(rawShape, true, true),\n    fn && userFnCall(),\n    softReader,\n  ]\n  forIn(obj, (child: Store<any> | any, key) => {\n    if (!is.store(child)) {\n      assert(\n        !is.unit(child) && !isVoid(child),\n        `combine expects a store in a field ${key}`,\n        errorTitle,\n      )\n      stateNew[key] = defaultState[key] = child\n      return\n    }\n    defaultState[key] = child.defaultState\n    stateNew[key] = child.getState()\n    const linkNode = createLinkNode(child, store, node, 'combine', fn)\n    linkNode.scope.key = key\n    const childRef = getStoreState(child)\n    addRefOp(rawShape, {type: 'field', field: key, from: childRef})\n    applyTemplate('combineField', childRef, linkNode)\n  })\n\n  store.defaultShape = obj\n  addRefOp(storeStateRef, {\n    type: MAP,\n    from: rawShape,\n    fn,\n  })\n  if (!readTemplate()) {\n    if (fn) {\n      const computedValue = fn(stateNew)\n\n      if (isVoid(computedValue) && (!extConfig || !('skipVoid' in extConfig))) {\n        console.error(`${errorTitle}: ${requireExplicitSkipVoidMessage}`)\n      }\n\n      storeStateRef.current = computedValue\n      storeStateRef.initial = computedValue\n      store.defaultState = computedValue\n    } else {\n      store.defaultState = defaultState\n    }\n  }\n  return store\n}\n","import type {Defer} from './unit.h'\n\nexport function createDefer(): Defer {\n  const result = {} as Defer\n  result.req = new Promise((rs, rj) => {\n    result.rs = rs\n    result.rj = rj\n  })\n  result.req.catch(() => {})\n  return result\n}\n","import type {Unit, Stack} from './index.h'\nimport type {Effect, Scope} from './unit.h'\nimport {calc, run} from './step'\nimport {getForkPage, getGraph, getMeta, getParent, setMeta} from './getter'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {launch, setForkPage, forkPage, isWatch} from './kernel'\nimport {createStore, createEvent} from './createUnit'\nimport {createDefer} from './defer'\nimport {isObject, isFunction} from './is'\nimport {assert} from './throw'\nimport {EFFECT} from './tag'\nimport {add} from './collection'\nimport {flattenConfig} from './config'\nimport {nextEffectID} from './id'\nimport {generateErrorTitle} from './naming'\n\ntype RunnerData<Params, Done, Fail> = {\n  params: Params\n  req: {\n    rs(data: Done): void\n    rj(data: Fail): void\n  }\n  args?: [params: Params, computedParams: any] | [params: Params]\n  handler?: Function\n}\n\nexport function createEffect<Params, Done, Fail = Error>(\n  nameOrConfig: any,\n  maybeConfig: any = {},\n): Effect<Params, Done, Fail> {\n  const config = flattenConfig(\n    isFunction(nameOrConfig) ? {handler: nameOrConfig} : nameOrConfig,\n    maybeConfig,\n  )\n  const errorTitle = generateErrorTitle('effect', config)\n  const instance = createEvent(\n    isFunction(nameOrConfig) ? {handler: nameOrConfig} : nameOrConfig,\n    {...maybeConfig, actualOp: EFFECT},\n  ) as unknown as Effect<Params, Done, Fail>\n  const node = getGraph(instance)\n  setMeta(node, 'op', (instance.kind = EFFECT))\n  //@ts-expect-error\n  instance.use = (fn: Function) => {\n    assert(isFunction(fn), '.use argument should be a function', errorTitle)\n    runner.scope.handler = fn\n    return instance\n  }\n  instance.use.getCurrent = () => runner.scope.handler\n  const anyway = (instance.finally = createEvent({\n    named: 'finally',\n    derived: true,\n  }))\n  const done = (instance.done = (anyway as any).filterMap({\n    named: 'done',\n    fn({\n      status,\n      params,\n      result,\n    }: {\n      status: 'done' | 'fail'\n      params: Params\n      result: Done\n      error: Fail\n    }) {\n      if (status === 'done') return {params, result}\n    },\n  }))\n  const fail = (instance.fail = (anyway as any).filterMap({\n    named: 'fail',\n    fn({\n      status,\n      params,\n      error,\n    }: {\n      status: 'done' | 'fail'\n      params: Params\n      result: Done\n      error: Fail\n    }) {\n      if (status === 'fail') return {params, error}\n    },\n  }))\n  const doneData = (instance.doneData = done.map({\n    named: 'doneData',\n    fn: ({result}: {result: Done}) => result,\n  }))\n  const failData = (instance.failData = fail.map({\n    named: 'failData',\n    fn: ({error}: {error: Fail}) => error,\n  }))\n\n  const runner = createNode({\n    scope: {\n      handler:\n        instance.defaultConfig.handler ||\n        (() =>\n          assert(\n            false,\n            `no handler used in ${instance.compositeName.fullName}`,\n          )),\n    },\n    node: [\n      calc(\n        (upd: RunnerData<Params, Done, Fail>, scope_: any, stack) => {\n          let handler: Function = scope_.handler\n          const scope = getForkPage(stack)\n          if (scope) {\n            const scopeHandler =\n              scope.handlers.unitMap.get(instance) ||\n              scope.handlers.sidMap[instance.sid!]\n            if (scopeHandler) handler = scopeHandler\n          }\n          upd.handler = handler\n          return upd\n        },\n        false,\n        true,\n      ),\n      calc(\n        (\n          upd: RunnerData<Params, Done, Fail> & {handler: Function},\n          _,\n          stack,\n        ) => {\n          if (_.runnerFn) {\n            const needToContinue = _.runnerFn(upd, null, stack)\n            if (!needToContinue) return\n          }\n          /** upd.args could be changed by runnerFn */\n          const {params, req, handler, args = [params]} = upd\n          const onResolve = onSettled(params, req, true, anyway, stack)\n          const onReject = onSettled(params, req, false, anyway, stack)\n          const [ok, result] = runFn(handler, onReject, args)\n          if (ok) {\n            if (isObject(result) && isFunction(result.then)) {\n              result.then(onResolve, onReject)\n            } else {\n              onResolve(result)\n            }\n          }\n        },\n        false,\n        true,\n      ),\n    ],\n    meta: {op: 'fx', fx: 'runner'},\n  })\n  node.scope.runner = runner\n  add(\n    node.seq,\n    calc((params, {runner}, stack) => {\n      const upd: RunnerData<Params, Done, Fail> = getParent(stack)\n        ? {params, req: {rs(data: Done) {}, rj(data: Fail) {}}}\n        : /** empty stack means that this node was launched directly */\n          params\n      if (!stack.meta) {\n        stack.meta = {fxID: nextEffectID()}\n      }\n      launch({\n        target: runner,\n        params: upd,\n        defer: true,\n        scope: getForkPage(stack),\n        meta: stack.meta,\n      })\n      return upd.params\n    }),\n  )\n  //@ts-expect-error\n  instance.create = (params: Params) => {\n    const req = createDefer()\n    const payload = {params, req}\n    if (forkPage) {\n      if (!isWatch) {\n        const savedFork = forkPage\n        req.req\n          .finally(() => {\n            setForkPage(savedFork)\n          })\n          .catch(() => {})\n      }\n    }\n    launch({\n      target: instance,\n      params: payload,\n      scope: forkPage,\n    })\n    return req.req\n  }\n\n  const inFlight = (instance.inFlight = createStore(0, {\n    serialize: 'ignore',\n    named: (getMeta(instance, 'name') || instance.graphite.id) + '.inFlight',\n  })\n    .on(instance, x => x + 1)\n    .on(anyway, x => x - 1)\n    .map({\n      // @ts-expect-error\n      fn: x => x,\n      named: 'inFlight',\n    }))\n  setMeta(anyway, 'needFxCounter', 'dec')\n  setMeta(instance, 'needFxCounter', true)\n  const pending = (instance.pending = inFlight.map({\n    //@ts-expect-error\n    fn: amount => amount > 0,\n    named: 'pending',\n  }))\n\n  own(instance, [anyway, done, fail, doneData, failData, pending, inFlight])\n  if (config?.domain) {\n    config.domain.hooks.effect(instance)\n  }\n  return instance\n}\nexport const runFn = (\n  fn: Function,\n  onReject: (data: any) => void,\n  args: any[],\n): [boolean, any] => {\n  try {\n    return [true, fn(...args)]\n  } catch (err) {\n    onReject(err)\n    return [false, null]\n  }\n}\n\nexport const onSettled =\n  (\n    params: any,\n    req: {\n      rs(_: any): void\n      rj(_: any): void\n    },\n    ok: boolean,\n    anyway: Unit,\n    stack: Stack,\n  ) =>\n  (data: any) => {\n    launch({\n      target: [anyway, sidechain],\n      params: [\n        ok\n          ? {status: 'done', params, result: data}\n          : {status: 'fail', params, error: data},\n        {value: data, fn: ok ? req.rs : req.rj},\n      ],\n      defer: true,\n      // WARN! Will broke forest pages as they arent moved to new scope\n      page: stack.page,\n      scope: stack.scope,\n      meta: stack.meta,\n    })\n  }\nconst sidechain = createNode({\n  node: [run({fn: ({fn, value}) => fn(value)})],\n  meta: {op: 'fx', fx: 'sidechain'},\n})\n","import type {Domain} from './unit.h'\nimport {combine} from './combine'\nimport {createEffect, onSettled, runFn} from './createEffect'\nimport {applyParentHook} from './createUnit'\nimport {processArgsToConfig} from './config'\nimport {\n  getGraph,\n  getParent,\n  getStoreState,\n  setMeta,\n  getCompositeName,\n} from './getter'\nimport {own} from './own'\nimport {is, isVoid} from './is'\nimport {read, calc} from './step'\nimport {launch} from './kernel'\nimport {EFFECT} from './tag'\nimport {createName, generateErrorTitle} from './naming'\nimport {assert} from './throw'\nimport {Cmd, Node, Stack} from './index.h'\n\nexport function attach(config: any) {\n  let injected\n  ;[config, injected] = processArgsToConfig(config, true)\n  const errorTitle = generateErrorTitle('attach', injected)\n  let {source, effect, mapParams, domain} = config\n  if (is.effect(effect)) {\n    assert(\n      isVoid(domain),\n      '`domain` can only be used with a plain function',\n      errorTitle,\n    )\n  }\n  const attached = createEffect(config, injected)\n  setMeta(attached, 'attached', true)\n  const {runner} = getGraph(attached).scope as {runner: Node}\n  let runnerSteps: Array<Cmd>\n  const runnerFnStep = (upd: any, _: any, stack: Stack) => {\n    const {params, req, handler} = upd\n    const anyway = attached.finally\n    const rj = onSettled(params, req, false, anyway, stack)\n    const sourceData = stack.a\n    const isEffectHandler = is.effect(handler)\n    let ok = true\n    let computedParams\n    if (mapParams) {\n      ;[ok, computedParams] = runFn(mapParams, rj, [params, sourceData])\n    } else {\n      computedParams = source && isEffectHandler ? sourceData : params\n    }\n    if (ok) {\n      if (isEffectHandler) {\n        launch({\n          target: handler as any,\n          params: {\n            params: computedParams,\n            req: {\n              rs: onSettled(params, req, true, anyway, stack),\n              rj,\n            },\n          },\n          page: stack.page,\n          defer: true,\n          meta: stack.meta,\n        })\n      } else {\n        upd.args = [sourceData, computedParams]\n        return true\n      }\n    }\n  }\n  if (source) {\n    runner.scope.runnerFn = runnerFnStep\n    let state\n    if (is.store(source)) {\n      state = source\n      own(state, [attached])\n    } else {\n      state = combine(source)\n      own(attached, [state])\n    }\n    runnerSteps = [\n      /**\n       * effect computation should run in effect queue,\n       * but reading state too early leads to data races\n       * so we add additional empty step\n       **/\n      calc(upd => upd, false, true),\n      read(getStoreState(state)),\n    ]\n    /**\n     * in simple effect, seq consists of two steps\n     * first prepares handler and the second actually calls it\n     *\n     * we delete priority, as we already in effect queue\n     * so additional delay is not needed\n     *\n     * curiously, presence of effect here leads to stale values\n     * because if effect step is not first in a sequence\n     * it will be placed in queue\n     * to prevent data races: effects should be called in order,\n     * but before we run effect in a queue, we should run\n     * more important tasks at first, so it should execute like this:\n     *\n     *    pure queue: [node [mov foo reg_a, effect a]]\n     *    effect queue: [node [effect b]]\n     *\n     *    order: mov foo reg_a, effect b, effect a\n     *\n     * but when node is executed, everything in it will run sequentially\n     * so kernel will find \"effect a\" earlier than already queued \"effect b\"\n     *\n     * this behavior leads to state reading happened before another effect handlers\n     * execution and in this case we dont want that, as it leads\n     * to reading values which are going to change\n     */\n    delete runner.seq[1].order\n  } else {\n    runnerSteps = [calc(runnerFnStep, true, true)]\n  }\n  runner.seq.splice(1, 0, ...runnerSteps)\n  attached.use(effect)\n  const parentDomain: Domain | void = getParent(effect)\n  if (parentDomain) {\n    Object.assign(\n      getCompositeName(attached),\n      createName(attached.shortName, parentDomain),\n    )\n    attached.defaultConfig.parent = parentDomain\n  }\n  applyParentHook(effect, attached, EFFECT)\n  return attached\n}\n","import type {Store, Event} from './unit.h'\nimport {createEvent, applyParentHook} from './createUnit'\nimport {forIn} from './collection'\nimport {getParent} from './getter'\nimport {processArgsToConfig} from './config'\n\nexport function createApi(...args: [Store<any>, {[key: string]: Function}]) {\n  let [[store, setters], metadata] = processArgsToConfig(args)\n  const result: Record<string, Event<any>> = {}\n  forIn(setters, (fn, key) => {\n    const event = (result[key] = createEvent(key, {\n      parent: getParent(store),\n      config: metadata,\n    }))\n    store.on(event, fn)\n    applyParentHook(store, event)\n  })\n  return result\n}\n","import type {Domain} from './unit.h'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport type {Config, NodeUnit} from './index.h'\nimport {\n  createEvent,\n  createNamedEvent,\n  createStore,\n  initUnit,\n} from './createUnit'\nimport {createEffect} from './createEffect'\nimport {createLinkNode} from './forward'\nimport {add, forEach, forIn} from './collection'\nimport {getGraph, getParent} from './getter'\nimport {DOMAIN} from './tag'\nimport {launch} from './kernel'\nimport {calc} from './step'\nimport {flattenConfig} from './config'\n\nexport function createDomain(nameOrConfig: any, maybeConfig?: any): Domain {\n  const config = flattenConfig({\n    or: maybeConfig,\n    and: typeof nameOrConfig === 'string' ? {name: nameOrConfig} : nameOrConfig,\n  }) as any\n\n  const node = createNode({\n    family: {type: DOMAIN},\n    regional: true,\n    parent: config?.domain || config?.parent,\n  })\n\n  const domain = {\n    history: {},\n    graphite: node,\n    hooks: {},\n  } as Domain\n\n  node.meta = initUnit(DOMAIN, domain, {\n    parent: config?.domain || config?.parent,\n    or: {...config, derived: true},\n  })\n\n  forIn(\n    {\n      Event: createEvent,\n      Effect: createEffect,\n      Store: createStore,\n      Domain: createDomain,\n    },\n    (factory, tag) => {\n      const lowerCaseTag = tag.toLowerCase() as\n        | 'event'\n        | 'effect'\n        | 'store'\n        | 'domain'\n\n      const onCreateUnit = createNamedEvent(`on${tag}`)\n      domain.hooks[lowerCaseTag] = onCreateUnit\n\n      const history = new Set<any>()\n      domain.history[`${lowerCaseTag}s`] = history\n\n      onCreateUnit.create = unit => {\n        launch(onCreateUnit, unit)\n        return unit\n      }\n      add(\n        getGraph(onCreateUnit).seq,\n        calc((upd, _, stack) => {\n          stack.scope = null\n          return upd\n        }),\n      )\n      onCreateUnit.watch(unit => {\n        own(domain, [unit])\n        history.add(unit)\n        if (!unit.ownerSet) unit.ownerSet = history\n        if (!getParent(unit)) unit.parent = domain\n      })\n      own(domain, [onCreateUnit])\n\n      domain[`onCreate${tag}`] = (hook: (unit: any) => any) => {\n        forEach(history, hook)\n        return onCreateUnit.watch(hook)\n      }\n      domain[`create${tag}`] = domain[lowerCaseTag] = (\n        nameOrConfig: any,\n        rawConfig?: Config,\n      ) => {\n        const config = flattenConfig({and: rawConfig, or: nameOrConfig})\n        if (config?.domain) {\n          // @ts-expect-error complicated factory type\n          return factory(nameOrConfig, rawConfig)\n        }\n        // @ts-expect-error complicated factory type\n        return onCreateUnit(factory(nameOrConfig, {parent: domain, or: config}))\n      }\n    },\n  )\n\n  const parent = getParent(domain)\n  if (parent) {\n    forIn(domain.hooks, (from: NodeUnit, key) =>\n      createLinkNode(from, parent.hooks[key]),\n    )\n  }\n  if (config?.domain) {\n    config.domain.hooks.domain(domain)\n  }\n  return domain\n}\n","import {observableSymbol} from './observable'\nimport type {Event} from './unit.h'\nimport {createEvent} from './createUnit'\nimport {assertObject} from './is'\nimport {assert} from './throw'\nimport {createSubscription} from './subscription'\n\nexport function fromObservable<T>(observable: any): Event<T> {\n  assertObject(observable)\n  const observableItem =\n    observableSymbol in observable ? observable[observableSymbol]() : observable\n  assert(observableItem.subscribe, 'expect observable to have .subscribe')\n  const event = createEvent<T>()\n  const disposer = createSubscription(event)\n  observableItem.subscribe({\n    next: event,\n    error: disposer,\n    complete: disposer,\n  })\n  return event\n}\n","import type {Store, Event, Effect} from './unit.h'\nimport {createEvent} from './createUnit'\nimport {createLinkNode} from './forward'\nimport {generateErrorTitle, unitObjectName} from './naming'\nimport {assertNodeSet} from './is'\n\nexport function merge<T>(\n  units: Array<Event<T> | Store<T> | Effect<T, any, any>>,\n  config?: object,\n): Event<T> {\n  const errorTitle = generateErrorTitle('merge', config)\n  assertNodeSet(units, errorTitle, 'first argument')\n  const result = createEvent({\n    name: unitObjectName(units, 'merge'),\n    derived: true,\n    and: config,\n  })\n  createLinkNode(units, result, [], 'merge')\n  return result\n}\n","import type {Cmd, StateRef} from './index.h'\nimport type {CommonUnit, DataCarrier} from './unit.h'\nimport {combine} from './combine'\nimport {mov, userFnCall, read, calc} from './step'\nimport {createStateRef, readRef} from './stateRef'\nimport {callStackAReg} from './caller'\nimport {processArgsToConfig} from './config'\nimport {getStoreState, getGraph} from './getter'\nimport {\n  assertNodeSet,\n  assertTarget,\n  is,\n  isObject,\n  isVoid,\n  isFunction,\n} from './is'\nimport {createStore} from './createUnit'\nimport {createEvent} from './createUnit'\nimport {createNode} from './createNode'\nimport {assert, deprecate} from './throw'\nimport {forEach} from './collection'\nimport {STACK, VALUE} from './tag'\nimport {merge} from './merge'\nimport {applyTemplate} from './template'\nimport {own} from './own'\nimport {createLinkNode} from './forward'\nimport {generateErrorTitle} from './naming'\n\nconst sampleConfigFields = ['source', 'clock', 'target']\n\nconst fieldErrorMessage = (method: string, field: string) =>\n  method + `: ${field} should be defined`\n\nexport function validateSampleConfig(config: any, method: string) {\n  let atLeastOneFieldExists = false\n  forEach(sampleConfigFields, field => {\n    if (field in config) {\n      assert(config[field] != null, fieldErrorMessage(method, field))\n      atLeastOneFieldExists = true\n    }\n  })\n  return atLeastOneFieldExists\n}\n\nexport function sample(...args: any[]) {\n  let target\n  let name\n  let [[source, clock, fn], metadata] = processArgsToConfig(args)\n  let sid\n  let batch = true\n  let filter\n  const errorTitle = generateErrorTitle('sample', metadata)\n  /** config case */\n  if (\n    isVoid(clock) &&\n    isObject(source) &&\n    validateSampleConfig(source, errorTitle)\n  ) {\n    clock = source.clock\n    fn = source.fn\n    if ('batch' in source) {\n      batch = source.batch\n    } else {\n      deprecate(!('greedy' in source), 'greedy in sample', 'batch', errorTitle)\n      batch = !source.greedy\n    }\n    filter = source.filter\n    /** optional target & name accepted only from config */\n    target = source.target\n    name = source.name\n    sid = source.sid\n    source = source.source\n  }\n  return createSampling(\n    'sample',\n    clock,\n    source,\n    filter,\n    target,\n    fn,\n    name,\n    metadata,\n    batch,\n    true,\n    false,\n    sid,\n  )\n}\n\nexport const createSampling = (\n  method: string,\n  clock: DataCarrier | DataCarrier[] | void,\n  source: DataCarrier | Array<Store<any>> | Record<string, Store<any>> | void,\n  filter: any,\n  target: DataCarrier | DataCarrier[] | void,\n  fn: any,\n  name: string | undefined,\n  metadata: object | void,\n  batch: boolean,\n  targetMayBeStore: boolean,\n  filterRequired: boolean,\n  sid?: string | undefined,\n) => {\n  const errorTitle = generateErrorTitle(method, metadata)\n  const isUpward = !!target\n  assert(\n    !isVoid(source) || !isVoid(clock),\n    fieldErrorMessage(errorTitle, 'either source or clock'),\n  )\n  let sourceIsClock = false\n  if (isVoid(source)) {\n    sourceIsClock = true\n  } else if (!is.unit(source)) {\n    source = combine(source)\n  }\n  if (isVoid(clock)) {\n    /** still undefined! */\n    clock = source\n  } else {\n    assertNodeSet(clock, errorTitle, 'clock')\n    if (Array.isArray(clock)) {\n      clock = merge(clock as CommonUnit[])\n    }\n  }\n  if (sourceIsClock) {\n    source = clock\n  }\n  // @ts-expect-error\n  if (!metadata && !name) name = source.shortName\n  let filterType: 'none' | 'unit' | 'fn' = 'none'\n  if (filterRequired || filter) {\n    if (is.unit(filter)) {\n      filterType = 'unit'\n    } else {\n      assert(isFunction(filter), '`filter` should be function or unit')\n      filterType = 'fn'\n    }\n  }\n  if (target) {\n    assertNodeSet(target, errorTitle, 'target')\n    assertTarget(errorTitle, target)\n  } else {\n    if (\n      filterType === 'none' &&\n      targetMayBeStore &&\n      is.store(source) &&\n      is.store(clock)\n    ) {\n      const initialState = fn\n        ? fn(readRef(getStoreState(source)), readRef(getStoreState(clock)))\n        : readRef(getStoreState(source))\n      // @ts-expect-error\n      target = createStore(initialState, {name, sid, or: metadata})\n    } else {\n      target = createEvent({name, derived: true, or: metadata})\n      applyTemplate('sampleTarget', getGraph(target))\n    }\n  }\n  // const targetTemplate =\n  //   isUpward && is.unit(target) && getGraph(target).meta.nativeTemplate\n  const clockState = createStateRef()\n  let filterNodes: Cmd[] = []\n  if (filterType === 'unit') {\n    const [filterRef, hasFilter, isFilterStore] = syncSourceState(\n      filter as DataCarrier,\n      target,\n      // @ts-expect-error\n      clock,\n      clockState,\n      method,\n    )\n    if (!isFilterStore) {\n      filterNodes.push(...readAndFilter(hasFilter))\n    }\n    filterNodes.push(...readAndFilter(filterRef))\n  }\n  const jointNodeSeq: Cmd[] = []\n  if (sourceIsClock) {\n    if (batch) {\n      jointNodeSeq.push(read(clockState, true, true))\n    }\n  } else {\n    const [sourceRef, hasSource, isSourceStore] = syncSourceState(\n      // @ts-expect-error\n      source,\n      target,\n      clock,\n      clockState,\n      method,\n    )\n    if (!isSourceStore) {\n      jointNodeSeq.push(...readAndFilter(hasSource))\n    }\n    jointNodeSeq.push(read(sourceRef, true, batch))\n  }\n  const jointNode = createLinkNode(\n    // @ts-expect-error\n    clock,\n    target,\n    [\n      applyTemplate('sampleSourceLoader'),\n      mov({from: STACK, target: clockState}),\n      ...jointNodeSeq,\n      ...filterNodes,\n      read(clockState),\n      filterType === 'fn' && userFnCall((src, _, {a}) => filter(src, a), true),\n      fn && userFnCall(callStackAReg),\n      applyTemplate('sampleSourceUpward', isUpward),\n    ],\n    method,\n    fn,\n  )\n  // @ts-expect-error\n  own(source, [jointNode])\n  Object.assign(jointNode.meta, metadata, {joint: true})\n  return target\n}\n\nconst readAndFilter = (state: StateRef) => [\n  read(state),\n  calc((upd, scope, {a}) => a, true),\n]\n\nconst syncSourceState = (\n  source: DataCarrier,\n  target: DataCarrier | DataCarrier[],\n  clock: DataCarrier | DataCarrier[],\n  clockState: StateRef,\n  method: string,\n) => {\n  const isSourceStore = is.store(source)\n  const sourceRef = isSourceStore ? getStoreState(source) : createStateRef()\n  const hasSource = createStateRef(isSourceStore)\n  if (!isSourceStore) {\n    createNode({\n      parent: source,\n      node: [\n        mov({from: STACK, target: sourceRef}),\n        mov({from: VALUE, store: true, target: hasSource}),\n      ],\n      family: {owners: [source, target, clock], links: target},\n      meta: {op: method},\n      regional: true,\n    })\n  }\n  applyTemplate('sampleSource', hasSource, sourceRef, clockState)\n  return [sourceRef, hasSource, isSourceStore] as const\n}\n","import {processArgsToConfig} from './config'\nimport {generateErrorTitle} from './naming'\nimport {validateSampleConfig, createSampling} from './sample'\nimport {deprecate} from './throw'\n\nexport function guard(...args: any[]) {\n  let [[source, config], metadata] = processArgsToConfig(args)\n  const errorTitle = generateErrorTitle('guard', metadata)\n  deprecate(false, 'guard', 'sample', errorTitle)\n  if (!config) {\n    config = source\n    source = config.source\n  }\n  validateSampleConfig(config, errorTitle)\n  return createSampling(\n    'guard',\n    config.clock,\n    source,\n    config.filter,\n    config.target,\n    null,\n    config.name,\n    metadata,\n    !config.greedy,\n    false,\n    true,\n  )\n}\n","import {createStore} from './createUnit'\nimport {is} from './is'\nimport {forIn} from './collection'\nimport {getParent} from './getter'\nimport {createLinkNode} from './forward'\nimport {assert} from './throw'\nimport {generateErrorTitle} from './naming'\n\nexport function restore(obj: any, defaultState: any, config?: any) {\n  const errorTitle = generateErrorTitle('restore', config)\n  assert(!is.store(obj), 'restore($store) is not supported', errorTitle)\n  if (is.event(obj) || is.effect(obj)) {\n    const domain = getParent(obj)\n    const result = createStore(defaultState, {\n      parent: domain,\n      name: obj.shortName,\n      and: config,\n    })\n    createLinkNode(is.effect(obj) ? obj.doneData : obj, result)\n    if (domain) domain.hooks.store(result)\n    return result\n  }\n  const result: Record<string, any> = Array.isArray(obj) ? [] : {}\n  forIn(\n    obj,\n    (value, key) =>\n      (result[key] = is.store(value) ? value : createStore(value, {name: key})),\n  )\n  return result\n}\n","import type {DataCarrier} from './unit.h'\nimport type {Cmd, Stack} from './index.h'\nimport {is, isFunction, isObject, assertTarget} from './is'\nimport {add, forIn, includes} from './collection'\nimport {addRefOp, createStateRef} from './stateRef'\nimport {createLinkNode} from './forward'\nimport {processArgsToConfig} from './config'\nimport {compute, userFnCall, calc, read} from './step'\nimport {createNode} from './createNode'\nimport {launch} from './kernel'\nimport {getStoreState} from './getter'\nimport {assert} from './throw'\nimport {createEvent} from './createUnit'\nimport {applyTemplate} from './template'\nimport {createSampling} from './sample'\nimport {generateErrorTitle} from './naming'\n\nconst launchCase = (\n  scopeTargets: Record<string, DataCarrier>,\n  field: string,\n  data: any,\n  stack: Stack,\n) => {\n  const target = scopeTargets[field]\n  if (target) {\n    launch({\n      target,\n      params: Array.isArray(target) ? target.map(() => data) : data,\n      defer: true,\n      stack,\n    })\n  }\n}\n\nexport function split(...args: any[]) {\n  const METHOD = 'split'\n  let targets: Record<string, DataCarrier>\n  let clock: void | DataCarrier | DataCarrier[]\n  let [[source, match], metadata] = processArgsToConfig(args)\n  const errorTitle = generateErrorTitle(METHOD, metadata)\n  const configForm = !match\n  if (configForm) {\n    targets = source.cases\n    match = source.match\n    clock = source.clock\n    source = source.source\n  }\n  const matchIsUnit = is.store(match)\n  const matchIsFunction = !is.unit(match) && isFunction(match)\n  const matchIsShape = !matchIsUnit && !matchIsFunction && isObject(match)\n  assert(is.unit(source), 'source must be a unit', errorTitle)\n  if (!targets!) targets = {}\n  if (!configForm) {\n    assert(matchIsShape, 'match should be an object', errorTitle)\n    forIn(\n      match,\n      (_, key) =>\n        (targets[key] = createEvent({\n          derived: true,\n          named: `cases.${key}`,\n          and: metadata,\n        })),\n    )\n    targets.__ = createEvent({\n      derived: true,\n      named: 'cases.__',\n      and: metadata,\n    })\n  } else {\n    forIn(targets, (target, field) =>\n      assertTarget(errorTitle, target, `cases.${field}`),\n    )\n  }\n  const owners = new Set(\n    ([] as DataCarrier[]).concat(source, clock || [], Object.values(targets)),\n  )\n  const caseNames = Object.keys(\n    matchIsUnit || matchIsFunction ? targets : match,\n  )\n  let splitterSeq: Array<Cmd | false>\n  if (matchIsUnit || matchIsFunction) {\n    if (matchIsUnit) owners.add(match)\n    splitterSeq = [\n      matchIsUnit && read(getStoreState(match), false, true),\n      compute({\n        safe: matchIsUnit,\n        filter: true,\n        pure: !matchIsUnit,\n        fn(data, scopeTargets, stack) {\n          const value = String(matchIsUnit ? stack.a : match(data))\n          launchCase(\n            scopeTargets,\n            includes(caseNames, value) ? value : '__',\n            data,\n            stack,\n          )\n        },\n      }),\n    ]\n  } else if (matchIsShape) {\n    const lastValues = createStateRef({})\n    lastValues.type = 'shape'\n    const units = [] as string[]\n    let needBarrier: boolean\n    forIn(match, (storeOrFn, key) => {\n      if (is.unit(storeOrFn)) {\n        needBarrier = true\n        add(units, key)\n        // @ts-expect-error\n        owners.add(storeOrFn)\n        const updater = createLinkNode(\n          storeOrFn,\n          [],\n          [read(lastValues), calc((upd, _, {a}) => (a[key] = upd))],\n        )\n        if (is.store(storeOrFn)) {\n          lastValues.current[key] = storeOrFn.getState()\n          const storeRef = getStoreState(storeOrFn)\n          addRefOp(lastValues, {from: storeRef, field: key, type: 'field'})\n          applyTemplate('splitMatchStore', storeRef, updater)\n        }\n      }\n    })\n    if (needBarrier!) {\n      applyTemplate('splitBase', lastValues)\n    }\n    splitterSeq = [\n      needBarrier! && read(lastValues, false, true),\n      userFnCall((data, scopeTargets, stack) => {\n        for (let i = 0; i < caseNames.length; i++) {\n          const caseName = caseNames[i]\n          const caseValue = includes(units, caseName)\n            ? stack.a[caseName]\n            : match[caseName](data)\n          if (caseValue) {\n            launchCase(scopeTargets, caseName, data, stack)\n            return\n          }\n        }\n        launchCase(scopeTargets, '__', data, stack)\n      }, true),\n    ]\n  } else {\n    assert(false, 'expect match to be unit, function or object')\n  }\n  const splitterNode = createNode({\n    meta: {op: METHOD},\n    parent: clock ? [] : source,\n    scope: targets,\n    node: splitterSeq!,\n    family: {owners: Array.from(owners)},\n    regional: true,\n  })\n  if (clock) {\n    createSampling(\n      METHOD,\n      clock,\n      source,\n      null,\n      splitterNode,\n      null,\n      METHOD,\n      metadata,\n      /* non-batched */\n      false,\n      false,\n      false,\n    )\n  }\n  if (!configForm) return targets\n}\n","import {add} from '../collection'\nimport {createDefer} from '../defer'\nimport {getGraph} from '../getter'\nimport {is} from '../is'\nimport {launch, forkPage} from '../kernel'\nimport {generateErrorTitle} from '../naming'\nimport type {Scope, Event, Effect, DataCarrier, SettledDefer} from '../unit.h'\n\nexport function allSettled<T>(\n  start: Event<T> | Effect<T, any, any> | Scope,\n  //@ts-expect-error its optional in correct cases\n  {scope, params: ctx}: {scope: Scope; params?: unknown} = {},\n) {\n  if (!is.unit(start))\n    return Promise.reject(new Error('first argument should be unit'))\n  if (\n    !is.effect(start) &&\n    !is.event(start) &&\n    !is.store(start) &&\n    !is.scope(start)\n  )\n    return Promise.reject(\n      new Error(\n        'first argument accepts only effects, events, stores or scopes',\n      ),\n    )\n  /** duplicated check because of ts validation */\n  if (is.scope(start)) {\n    scope = start\n  } else if (!is.targetable(start)) {\n    const errorTitle = generateErrorTitle('allSettled', getGraph(start).meta)\n    return Promise.reject(Error(`${errorTitle}: unit should be targetable`))\n  }\n  const defer = createDefer() as SettledDefer\n  defer.parentFork = forkPage\n  const {fxCount} = scope\n  add(fxCount.scope.defers, defer)\n\n  const launchUnits: DataCarrier[] = []\n  const launchParams: Array<{params: unknown; req: unknown} | null> = []\n  if (!is.scope(start)) {\n    add(launchUnits, start)\n    add(\n      launchParams,\n      is.effect(start)\n        ? {\n            params: ctx,\n            req: {\n              rs(value: unknown) {\n                defer.value = {status: 'done', value}\n              },\n              rj(value: unknown) {\n                defer.value = {status: 'fail', value}\n              },\n            },\n          }\n        : ctx,\n    )\n  }\n  add(launchUnits, fxCount)\n  add(launchParams, null)\n  launch({\n    target: launchUnits,\n    params: launchParams,\n    scope,\n  })\n  return defer.req\n}\n","import {getMeta, getOwners, getLinks} from '../getter'\nimport {is} from '../is'\nimport {assert} from '../throw'\nimport type {Store, Effect, ValuesMap, HandlersMap} from '../unit.h'\nimport type {Node, Unit} from '../index.h'\nimport {add, forEach, includes} from '../collection'\nimport {STORE} from '../tag'\n\nexport function traverseStores(\n  root: Node,\n  fn: (node: Node, sid: string | null) => void,\n  needSidlessStores: true,\n): void\nexport function traverseStores(\n  root: Node,\n  fn: (node: Node, sid: string) => void,\n): void\nexport function traverseStores(\n  root: Node,\n  fn: (node: Node, sid: string) => void,\n  needSidlessStores?: boolean,\n) {\n  const list = [] as Node[]\n  ;(function visit(node) {\n    if (includes(list, node)) return\n    add(list, node)\n    if (getMeta(node, 'op') === STORE) {\n      if (needSidlessStores || getMeta(node, 'sid')) {\n        fn(node, getMeta(node, 'sid'))\n      }\n    }\n    forEach(node.next, visit)\n    forEach(getOwners(node), visit)\n    forEach(getLinks(node), visit)\n  })(root)\n}\n\ntype StoreOrEffect = Store<any> | Effect<any, any, any>\n\nexport function normalizeValues(\n  values: ValuesMap | HandlersMap,\n  assertEach?: (key: StoreOrEffect, value: any) => void,\n) {\n  const mapOrRecordValues: Map<StoreOrEffect, any> | Record<string, any> =\n    Array.isArray(values) ? new Map(values as [StoreOrEffect, any][]) : values\n  const unitMap = new Map<Unit<any>, any>()\n  let hasSidDoubles = false\n  if (mapOrRecordValues instanceof Map) {\n    const sidMap = {} as Record<string, any>\n    forEach(mapOrRecordValues, (value, key) => {\n      assert(\n        (is.unit as (val: unknown) => val is StoreOrEffect)(key),\n        'Map key should be a unit',\n      )\n      if (assertEach) assertEach(key, value)\n      if (key.sid) {\n        if (key.sid in sidMap) hasSidDoubles = true\n        sidMap[key.sid!] = value\n      }\n      unitMap.set(key, value)\n    })\n    return {sidMap, unitMap, hasSidDoubles}\n  }\n  return {sidMap: mapOrRecordValues, unitMap}\n}\n","import {is} from '../is'\nimport {assert, deprecate} from '../throw'\nimport type {Domain, ValuesMap, HandlersMap, Scope, Store} from '../unit.h'\nimport {normalizeValues} from './util'\nimport {createScope} from './createScope'\nimport {forEach} from '../collection'\nimport {getMeta} from '../getter'\n\ntype ForkConfig = {\n  values?: ValuesMap\n  handlers?: HandlersMap\n}\n\nexport function fork(\n  domainOrConfig?: Domain | ForkConfig,\n  optionalConfig?: ForkConfig,\n) {\n  let config: ForkConfig | void = domainOrConfig as any\n  let domain: Domain\n  if (is.domain(domainOrConfig)) {\n    deprecate(false, 'fork(domain)', 'fork()')\n    domain = domainOrConfig\n    config = optionalConfig\n  }\n\n  const scope = createScope(domain!)\n\n  if (config) {\n    if (config.values) {\n      const {sidMap, unitMap, hasSidDoubles} = normalizeValues(\n        config.values,\n        unit => \n          assert(is.store(unit) && is.targetable(unit), 'Values map can contain only writable stores as keys'),\n      )\n      Object.assign(scope.values.sidMap, sidMap)\n      forEach(unitMap, (value, unit) => {\n        scope.values.idMap[(unit as Store<any>).stateRef.id] = value\n\n        /**\n         * If store values were provided as tuple or map,\n         * but unit has sid anyway, we should add it to sidIdMap,\n         * \n         * It is needed to avoid issues, if there are duplicated sids in the code + values is a tuple or map\n         */\n        scope.sidIdMap[getMeta(unit, 'sid')] = (unit as Store<any>).stateRef.id\n\n        const serialize = getMeta(unit, 'serialize')\n        if (serialize === 'ignore') {\n          const sid = getMeta(unit, 'sid')\n          scope.sidSerializeSettings.set(sid, {ignore: true})\n        }\n      })\n      scope.fromSerialize =\n        !Array.isArray(config.values) && !(config.values instanceof Map)\n      scope.hasSidDoubles = hasSidDoubles\n    }\n    if (config.handlers) {\n      deprecate(\n        config.handlers instanceof Map || Array.isArray(config.handlers),\n        'object with handlers',\n        'array',\n      )\n      scope.handlers = normalizeValues(config.handlers, unit =>\n        assert(\n          is.effect(unit),\n          `Handlers map can contain only effects as keys`,\n        ),\n      )\n    }\n  }\n  return scope\n}\n","import {getForkPage, getGraph} from '../getter'\nimport {setForkPage, getPageRef, currentPage} from '../kernel'\nimport {createNode} from '../createNode'\nimport {calc, compute} from '../step'\nimport type {Domain, Scope, SettledDefer, Store} from '../unit.h'\nimport type {Stack, StateRef} from '../index.h'\nimport {forEach} from '../collection'\nimport {DOMAIN, SAMPLER, SCOPE} from '../tag'\n\nexport function createScope(unit?: Domain): Scope {\n  const forkInFlightCounter = createNode({\n    scope: {\n      defers: [],\n      inFlight: 0,\n      fxID: 0,\n    },\n    node: [\n      calc((_, scope, stack) => {\n        if (!stack.parent) {\n          scope.fxID += 1\n          return\n        }\n        if (stack.parent.node.meta.needFxCounter === 'dec') {\n          scope.inFlight -= 1\n        } else {\n          scope.inFlight += 1\n          scope.fxID += 1\n        }\n      }),\n      compute({priority: SAMPLER, batch: true}),\n      calc(\n        (\n          _,\n          scope: {\n            inFlight: number\n            fxID: number\n            defers: SettledDefer[]\n          },\n        ) => {\n          const {defers, fxID} = scope\n          if (scope.inFlight > 0 || defers.length === 0) return\n          Promise.resolve().then(() => {\n            if (scope.fxID !== fxID) return\n            forEach(defers.splice(0, defers.length), defer => {\n              setForkPage(defer.parentFork)\n              defer.rs(defer.value)\n            })\n          })\n        },\n        false,\n        true,\n      ),\n    ],\n  })\n  const page = {} as Record<string, StateRef>\n  const storeChange = createNode({\n    node: [\n      calc((value, __, stack) => {\n        const storeStack = stack.parent\n        if (storeStack) {\n          const storeNode = storeStack.node\n          if (isNotCombineNode(storeStack)) {\n            const forkPage = getForkPage(stack)!\n            const id = storeNode.scope.state.id\n            const sid = storeNode.meta.sid\n            forkPage.sidIdMap[sid] = id\n            forkPage.values.sidMap[sid] = value\n\n            const serialize = storeNode.meta.serialize\n            if (serialize) {\n              if (serialize === 'ignore') {\n                forkPage.sidSerializeSettings.set(sid, {ignore: true})\n              } else {\n                forkPage.sidSerializeSettings.set(sid, {\n                  ignore: false,\n                  write: serialize.write,\n                })\n              }\n            }\n          }\n        }\n      }),\n    ],\n  })\n  const warnSerializeNode = createNode({\n    node: [\n      calc((_, __, stack) => {\n        const forkPage = getForkPage(stack)\n        if (forkPage && stack.parent) {\n          if (isNotCombineNode(stack.parent)) {\n            forkPage.warnSerialize = true\n          }\n        }\n      }),\n    ],\n  })\n  const resultScope: Scope = {\n    cloneOf: unit,\n    reg: page,\n    values: {sidMap: {}, idMap: {}},\n    sidIdMap: {},\n    sidSerializeSettings: new Map(),\n    getState(store: StateRef | Store<any>) {\n      if ('current' in store) {\n        return getPageRef(currentPage, resultScope, store, false).current\n      }\n      const node = getGraph(store)\n      return getPageRef(currentPage, resultScope, node.scope.state, true)\n        .current\n    },\n    kind: SCOPE,\n    graphite: createNode({\n      family: {\n        type: DOMAIN,\n        links: [forkInFlightCounter, storeChange, warnSerializeNode],\n      },\n      meta: {unit: 'fork'},\n      scope: {forkInFlightCounter},\n    }),\n    additionalLinks: {},\n    handlers: {sidMap: {}, unitMap: new Map()},\n    fxCount: forkInFlightCounter,\n    storeChange,\n    warnSerializeNode,\n  }\n  return resultScope\n}\n\nconst isNotCombineNode = (storeStack: Stack) =>\n  !storeStack.node.meta.isCombine ||\n  (storeStack.parent && storeStack.parent.node.meta.op !== 'combine')\n","import {is, isObject} from '../is'\nimport {assert, deprecate} from '../throw'\nimport {launch} from '../kernel'\nimport type {Domain, Scope, ValuesMap, Store} from '../unit.h'\nimport type {Node} from '../index.h'\nimport {add, forEach, includes} from '../collection'\nimport {normalizeValues, traverseStores} from './util'\nimport {getGraph, getMeta} from '../getter'\n\n/**\n hydrate state on client\n\n const root = createDomain()\n hydrate(root, {\n  values: window.__initialState__\n})\n\n */\nexport function hydrate(domain: Domain | Scope, {values}: {values: ValuesMap}) {\n  assert(isObject(values), 'values property should be an object')\n  const {sidMap, unitMap} = normalizeValues(values)\n  const valuesSidList = Object.getOwnPropertyNames(sidMap)\n  const storesRefIdMap: Record<string, Store<any>> = {}\n  forEach(unitMap as unknown as Map<Store<any>, any>, (_, unit) => {\n    storesRefIdMap[unit.stateRef.id] = unit\n  })\n  // Array.from(unitMap.keys(),\n  const storeNodes: Node[] = []\n  const storeValues: any[] = []\n  let forkPage: Scope\n  let traverseTarget: Node\n  let needToAssign: true | void\n  if (is.scope(domain)) {\n    forkPage = domain\n    needToAssign = true\n    assert(forkPage.cloneOf, 'scope should be created from domain')\n    deprecate(false, 'hydrate(fork(domain), { values })', 'fork({ values })')\n    traverseTarget = getGraph(forkPage.cloneOf)\n  } else if (is.domain(domain)) {\n    deprecate(false, 'hydrate(domain, { values })', 'fork({ values })')\n    traverseTarget = getGraph(domain)\n  } else {\n    assert(false, 'first argument of hydrate should be domain or scope')\n  }\n  traverseStores(\n    traverseTarget!,\n    (node, sid) => {\n      // forkPage.sidIdMap[sid] = node.scope.state.id\n      if (sid && includes(valuesSidList, sid)) {\n        add(storeNodes, node)\n        const serializer = getMeta(node, 'serialize')\n        if (serializer && serializer !== 'ignore') {\n          sidMap[sid] = serializer.read(sidMap[sid])\n        }\n        add(storeValues, sidMap[sid])\n      } else if (node.scope.state.id in storesRefIdMap) {\n        add(storeNodes, node)\n        add(storeValues, unitMap.get(storesRefIdMap[node.scope.state.id]))\n      }\n    },\n    true,\n  )\n  launch({\n    target: storeNodes,\n    params: storeValues,\n    scope: forkPage!,\n  })\n  if (needToAssign) {\n    Object.assign(forkPage!.values.sidMap, sidMap)\n  }\n}\n","import {assert} from '../throw'\nimport {forkPage, setForkPage} from '../kernel'\nimport type {Scope} from '../unit.h'\n\n/** bind event to scope */\nexport function scopeBind(\n  unit: (x: any) => any,\n  {scope, safe}: {scope?: Scope; safe?: true} = {},\n) {\n  assert(scope || forkPage || safe, 'scopeBind: scope not found')\n  const targetForkPage = scope || forkPage!\n\n  return (x: any) => {\n    let final: any\n    let failed = false\n\n    const lastForkPage = forkPage\n    function restoreLastForkPage() {\n      setForkPage(lastForkPage)\n    }\n\n    setForkPage(targetForkPage)\n    try {\n      final = unit(x)\n    } catch (err) {\n      final = err\n      failed = true\n    }\n    restoreLastForkPage()\n\n    if (failed) throw final\n\n    if (final instanceof Promise) {\n      final.then(restoreLastForkPage, restoreLastForkPage)\n    }\n\n    return final\n  }\n}\n","import type {Scope, Store} from '../unit.h'\nimport {forIn, includes} from '../collection'\nimport {assert, deprecate} from '../throw'\nimport {traverseStores} from './util'\nimport {getGraph, getMeta} from '../getter'\n\nconst noopSerializer = (x: any) => x\n/**\n serialize state on server\n */\nexport function serialize(\n  scope: Scope,\n  config: {ignore?: Array<Store<any>>; onlyChanges?: boolean} = {},\n) {\n  if (scope.warnSerialize) {\n    console.error(\n      'There is a store without sid in this scope, its value is omitted',\n    )\n  }\n  assert(!scope.hasSidDoubles, 'duplicate sid found in this scope')\n  const ignoredStores = config.ignore ? config.ignore.map(({sid}) => sid) : []\n  const result = {} as Record<string, any>\n  forIn(scope.values.sidMap, (value, sid) => {\n    if (includes(ignoredStores, sid)) return\n    const id = scope.sidIdMap[sid]\n    const serializeSettings = scope.sidSerializeSettings.get(sid) ?? {\n      ignore: false,\n      write: noopSerializer,\n    }\n    if (serializeSettings.ignore) return\n    const serializer = serializeSettings.write\n    // if (!scope.changedStores.has(id)) return\n    if (id && id in scope.reg) {\n      result[sid] = serializer(scope.reg[id].current)\n    } else {\n      result[sid] = serializer(value)\n    }\n  })\n  if ('onlyChanges' in config) {\n    deprecate(false, 'onlyChanges')\n    if (!config.onlyChanges) {\n      assert(scope.cloneOf, 'scope should be created from domain')\n      traverseStores(getGraph(scope.cloneOf), (node, sid) => {\n        if (\n          !(sid in result) &&\n          !includes(ignoredStores, sid) &&\n          !getMeta(node, 'isCombine') &&\n          getMeta(node, 'serialize') !== 'ignore'\n        )\n          result[sid] = scope.getState(node as any)\n      })\n    }\n  }\n  return result\n}\n","import {clearNode} from './clearNode'\nimport {createNode} from './createNode'\nimport type {Subscription, Unit, Compute, MovStoreToRegister} from './index.h'\nimport {step} from './step'\nimport {Scope} from './unit.h'\nimport {addUnsubscribe} from './subscription'\nimport {is} from './is'\n\nexport function createWatch<T>({\n  unit,\n  fn,\n  scope,\n  batch,\n}: {\n  unit: Unit<T> | Unit<T>[]\n  fn: (value: T) => any\n  scope?: Scope\n  batch?: boolean\n}): Subscription {\n  const seq: (Compute | MovStoreToRegister)[] = [\n    step.run({fn: value => fn(value)}),\n  ]\n  if (batch) {\n    seq.unshift(step.compute({priority: 'sampler', batch: true}))\n  }\n  if (is.store(unit)) {\n    seq.unshift(\n      step.mov({\n        store: (unit as any).stateRef,\n        to: 'stack',\n      }),\n    )\n  }\n  const units = Array.isArray(unit) ? unit : [unit]\n  if (scope) {\n    const unsubs: (() => void)[] = []\n    const scopeLinks = scope.additionalLinks\n\n    units.forEach(u => {\n      const links = scopeLinks[u.graphite.id] || []\n      scopeLinks[u.graphite.id] = links\n\n      const node = createNode({\n        node: prepareSeq(seq, u),\n        meta: {\n          watchOp: u.kind,\n        },\n      })\n\n      links.push(node)\n\n      unsubs.push(() => {\n        const idx = links.indexOf(node)\n        if (idx !== -1) links.splice(idx, 1)\n        clearNode(node)\n      })\n    })\n    return addUnsubscribe(() => {\n      unsubs.forEach(u => u())\n    })\n  } else {\n    const node = createNode({\n      node: seq,\n      parent: units,\n      family: {owners: units},\n    })\n    return addUnsubscribe(() => {\n      clearNode(node)\n    })\n  }\n}\n\nfunction prepareSeq(seq: (Compute | MovStoreToRegister)[], unit: any) {\n  if (is.store(unit)) {\n    return [\n      step.mov({\n        store: (unit as any).stateRef,\n        to: 'stack',\n      }),\n      ...seq,\n    ]\n  }\n\n  return seq\n}\n","export const observableSymbol =\n  (typeof Symbol !== 'undefined' && Symbol.observable) || '@@observable'\n","import type {Node, StateRef, NodeUnit} from './index.h'\nimport type {Scope, Store, CommonUnit, Domain} from './unit.h'\n\nexport const getGraph = (graph: NodeUnit): Node =>\n  (graph as {graphite: Node}).graphite || graph\nexport const getOwners = (node: Node) => node.family.owners\nexport const getLinks = (node: Node) => node.family.links\nexport const getStoreState = (store: Store<any>): StateRef => store.stateRef\nexport const getValue = (stack: any) => stack.value\nexport const getSubscribers = (store: Store<any>) => store.subscribers\nexport const getParent = (unit: any) => unit.parent\nexport const getForkPage = (val: any): Scope | void => val.scope\nexport const getMeta = (unit: NodeUnit, field: string) =>\n  getGraph(unit).meta[field]\nexport const setMeta = (unit: NodeUnit, field: string, value: unknown) =>\n  (getGraph(unit).meta[field] = value)\nexport const getCompositeName = (unit: CommonUnit | Domain) =>\n  unit.compositeName\n","import type {Kind, Unit} from './index.h'\nimport type {Domain, Effect, Event, Scope, Store} from './unit.h'\nimport {DOMAIN, STORE, EVENT, EFFECT, SCOPE} from './tag'\nimport {isObject, isFunction} from './is'\nimport {getMeta} from './getter'\nimport { UnitTargetable } from 'effector'\n\nexport const unit = (obj: unknown): obj is Unit<any> =>\n  (isFunction(obj) || isObject(obj)) && 'kind' in obj\n\nconst is = (type: Kind) => (obj: unknown) => unit(obj) && obj.kind === type\n\nexport const store = is(STORE) as (value: unknown) => value is Store<unknown>\nexport const event = is(EVENT) as (value: unknown) => value is Event<unknown>\nexport const effect = is(EFFECT) as (\n  value: unknown,\n) => value is Effect<unknown, unknown, unknown>\nexport const targetable = (obj: unknown): obj is UnitTargetable<unknown> => unit(obj) && !!(obj as any).targetable\nexport const domain = is(DOMAIN) as (value: unknown) => value is Domain\nexport const scope = is(SCOPE) as (value: unknown) => value is Scope\nexport const attached = (unit: unknown) =>\n  effect(unit) && getMeta(unit, 'attached') === true\n","const idCount = () => {\n  let id = 0\n  return () => `${++id}`\n}\n\nexport const nextUnitID = idCount()\nexport const nextStepID = idCount()\nexport const nextNodeID = idCount()\nexport const nextEffectID = idCount()\n","import type {NodeUnit} from './index.h'\nimport {getGraph, getOwners, getLinks} from './getter'\nimport {DOMAIN, CROSSLINK} from './tag'\nimport {add, forEach} from './collection'\n\nexport const own = (ownerUnit: NodeUnit, links: NodeUnit[]) => {\n  const owner = getGraph(ownerUnit)\n  forEach(links, _link => {\n    const link = getGraph(_link)\n    if (owner.family.type !== DOMAIN) link.family.type = CROSSLINK\n    add(getOwners(link), owner)\n    add(getLinks(owner), link)\n  })\n}\n","export * as is from './validate'\nimport {forEach} from './collection'\nimport {assert, deprecate} from './throw'\nimport {arrifyNodes} from './createNode'\nimport type {NodeUnit} from './index.h'\nimport type {DataCarrier} from './unit.h'\nimport {getMeta} from './getter'\n\nexport const isObject = (value: unknown): value is Record<any, any> =>\n  typeof value === 'object' && value !== null\nexport const isFunction = (value: unknown): value is Function =>\n  typeof value === 'function'\n\nexport const isVoid = (value: unknown): value is void => value === undefined\n\nexport const assertObject = (value: unknown) =>\n  assert(\n    isObject(value) || isFunction(value),\n    'expect first argument be an object',\n  ) // or function\n\nconst assertNodeSetItem = (\n  value: unknown,\n  method: string,\n  valueName: string,\n  reason: string,\n): asserts value is DataCarrier =>\n  assert(\n    !(\n      (!isObject(value) && !isFunction(value)) ||\n      (!('family' in value) && !('graphite' in value))\n    ),\n    `${method}: expect ${valueName} to be a unit (store, event or effect)${reason}`,\n  )\n\nexport const assertNodeSet = (\n  value: unknown,\n  method: string,\n  valueName: string,\n) => {\n  if (Array.isArray(value)) {\n    forEach(value, (item, i) =>\n      assertNodeSetItem(item, method, `${i} item of ${valueName}`, ''),\n    )\n  } else {\n    //@ts-expect-error some ts assertion edge case\n    assertNodeSetItem(value, method, valueName, ' or array of units')\n  }\n}\n\nexport const assertTarget = (\n  method: string,\n  target: NodeUnit | NodeUnit[],\n  targetField: string = 'target',\n) =>\n  forEach(arrifyNodes(target), item =>\n    assert(\n      !getMeta(item, 'derived'),\n      `${method}: derived unit in \"${targetField}\" is not supported, use createStore/createEvent instead\"`,\n    ),\n  )\n","import type {Stack} from './index.h'\n\nexport const callStackAReg = (\n  stack: any,\n  {fn}: {[key: string]: any},\n  {a}: Stack,\n) => fn(stack, a)\nexport const callARegStack = (\n  stack: any,\n  {fn}: {[key: string]: any},\n  {a}: Stack,\n) => fn(a, stack)\nexport const callStack = (stack: any, {fn}: {[key: string]: any}, _: Stack) =>\n  fn(stack)\n","import type {\n  StateRef,\n  Compute,\n  MovValueToRegister,\n  MovValueToStore,\n  MovStoreToRegister,\n  MovStoreToStore,\n  MovRegisterToStore,\n  Stack,\n} from './index.h'\nimport {nextStepID} from './id'\nimport {EFFECT, REG_A, SAMPLER, STACK, STORE} from './tag'\nimport type {BarrierPriorityTag} from './kernel'\nimport {callStack} from './caller'\n\nconst cmd = <Type extends 'compute' | 'mov'>(\n  type: Type,\n  data: any,\n  priority?: BarrierPriorityTag | false,\n  batch?: boolean,\n) => {\n  const result: {\n    id: string\n    type: Type\n    data: any\n    order?: {\n      priority: BarrierPriorityTag\n      barrierID?: number\n    }\n  } = {\n    id: nextStepID(),\n    type,\n    data,\n  }\n  if (priority) {\n    result.order = {priority}\n    if (batch) result.order.barrierID = ++nextBarrierID\n  }\n  return result\n}\n\nlet nextBarrierID = 0\n\nexport const mov: {\n  <T>(data: {\n    from: 'value'\n    store: T\n    target: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovValueToStore<T>\n  <T>(data: {\n    from: 'value'\n    to: 'stack' | 'a' | 'b'\n    store: T\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovValueToRegister<T>\n  (data: {\n    from: 'a' | 'b' | 'stack'\n    target: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovRegisterToStore\n  (data: {\n    from: 'a' | 'b' | 'stack'\n    to: 'a' | 'b' | 'stack'\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovRegisterToStore\n  (data: {\n    store: StateRef\n    target: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovStoreToStore\n  (data: {\n    store: StateRef\n    to: 'stack' | 'a' | 'b'\n    batch?: boolean\n    priority?: BarrierPriorityTag | false\n  }): MovStoreToRegister\n  (data: {\n    store: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag | false\n  }): MovStoreToRegister\n  // (data: {\n  //   from?: 'value' | 'store' | 'stack' | 'a' | 'b'\n  //   to?: 'stack' | 'a' | 'b' | 'store'\n  //   store?: StateRef\n  //   target?: StateRef\n  // }): Mov\n} = ({\n  from = STORE,\n  store,\n  target,\n  to = target ? STORE : STACK,\n  batch,\n  priority,\n}: {\n  from?: 'value' | 'store' | 'stack' | 'a' | 'b'\n  to?: 'stack' | 'a' | 'b' | 'store'\n  store?: StateRef\n  target?: StateRef\n  batch?: boolean\n  priority?: BarrierPriorityTag | false\n}) => cmd('mov', {from, store, to, target}, priority, batch)\n\nexport const compute = <\n  LocalValues extends {[key: string]: any} = {[key: string]: any},\n>({\n  fn,\n  batch,\n  priority,\n  safe = false,\n  filter = false,\n  pure = false,\n}: {\n  fn?: (data: any, scope: LocalValues, stack: Stack) => any\n  batch?: boolean\n  priority?: BarrierPriorityTag | false\n  safe?: boolean\n  filter?: boolean\n  pure?: boolean\n}): Compute => cmd('compute', {fn, safe, filter, pure}, priority, batch)\n\nexport const filter = ({\n  fn,\n  pure,\n}: {\n  fn(data: any, scope: {[key: string]: any}, stack: Stack): any\n  pure?: boolean\n}) => compute({fn, filter: true, pure})\n\nexport const run = ({\n  fn,\n}: {\n  fn(data: any, scope: {[key: string]: any}, stack: Stack): any\n}) => compute({fn, priority: EFFECT})\n\nexport const calc = <\n  LocalValues extends {[key: string]: any} = {[key: string]: any},\n>(\n  fn: (data: any, scope: LocalValues, stack: Stack) => any,\n  filter?: boolean,\n  isEffect?: boolean,\n) => compute({fn, safe: true, filter, priority: isEffect && EFFECT})\n\n/**\n * `read(ref, true, true)`: **reg.stack** with **sampler** batch\n *\n * `read(ref, true, false)`: **reg.stack** without batch\n *\n * `read(ref, false, true)`: **reg.a** with **sampler** batch\n *\n * `read(ref, false, false)`: **reg.a** without batch\n *\n */\nexport const read = (\n  store: StateRef,\n  toStack?: boolean,\n  samplerPriority?: boolean,\n) =>\n  mov({\n    store,\n    to: toStack ? STACK : REG_A,\n    priority: samplerPriority && SAMPLER,\n    batch: true,\n  })\n\nexport const userFnCall = (\n  fn: (data: any, scope: {[key: string]: any}, stack: Stack) => any = callStack,\n  isFilter?: boolean,\n) => compute({fn, pure: true, filter: isFilter})\n\nexport const step = {mov, compute, filter, run}\n","import type {StateRef, StateRefOp} from './index.h'\nimport {nextStepID} from './id'\nimport {add} from './collection'\n\nexport const createStateRef = (current?: any): StateRef => ({\n  id: nextStepID(),\n  current,\n  initial: current,\n})\nexport const readRef = ({current}: StateRef | {current: any}) => current\n\nexport const addRefOp = (ref: StateRef, op: StateRefOp) => {\n  if (!ref.before) ref.before = []\n  add(ref.before!, op as any)\n}\n","import {Node, NodeUnit} from './index.h'\nimport {getGraph, getOwners, getLinks, getSubscribers} from './getter'\nimport {is} from './is'\nimport {removeItem} from './collection'\nimport {CROSSLINK} from './tag'\n\nconst removeFromNode = (currentNode: Node, targetNode: Node) => {\n  removeItem(currentNode.next, targetNode)\n  removeItem(getOwners(currentNode), targetNode)\n  removeItem(getLinks(currentNode), targetNode)\n}\nconst clearNodeNormalized = (\n  targetNode: Node,\n  deep: boolean,\n  isDomainUnit: boolean,\n) => {\n  targetNode.next.length = 0\n  targetNode.seq.length = 0\n  //@ts-expect-error\n  targetNode.scope = null\n  let currentNode\n  let list = getLinks(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (\n      deep ||\n      (isDomainUnit && targetNode.meta.op !== 'sample') ||\n      currentNode.family.type === CROSSLINK\n    ) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        currentNode.meta.op !== 'on' && isDomainUnit,\n      )\n    }\n  }\n  list = getOwners(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (isDomainUnit && currentNode.family.type === CROSSLINK) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        currentNode.meta.op !== 'on' && isDomainUnit,\n      )\n    }\n  }\n}\nconst clearMap = (map: Map<any, any> | Set<any>) => map.clear()\nexport const clearNode = (\n  graphite: NodeUnit,\n  {\n    deep,\n  }: {\n    deep?: boolean\n  } = {},\n) => {\n  let isDomainUnit = false\n  //@ts-expect-error\n  if (graphite.ownerSet) graphite.ownerSet.delete(graphite)\n  if (is.store(graphite)) {\n    clearMap(getSubscribers(graphite))\n  } else if (is.domain(graphite)) {\n    isDomainUnit = true\n    const history = graphite.history\n    clearMap(history.events)\n    clearMap(history.effects)\n    clearMap(history.stores)\n    clearMap(history.domains)\n  }\n  clearNodeNormalized(getGraph(graphite), !!deep, isDomainUnit)\n}\n","import {processArgsToConfig} from './config'\nimport {createNode} from './createNode'\nimport type {Subscription, NodeUnit, Cmd} from './index.h'\nimport {createSubscription} from './subscription'\nimport {assertNodeSet, assertTarget} from './is'\nimport {deprecate} from './throw'\nimport {generateErrorTitle} from './naming'\n\nexport const createLinkNode = (\n  parent: NodeUnit | NodeUnit[],\n  child: NodeUnit | NodeUnit[],\n  node?: Array<Cmd | false | void | null>,\n  op?: string,\n  scopeFn?: Function,\n) =>\n  createNode({\n    node,\n    parent,\n    child,\n    scope: {fn: scopeFn},\n    meta: {op},\n    family: {owners: [parent, child], links: child},\n    regional: true,\n  })\nexport const forward = (opts: {\n  from: NodeUnit | NodeUnit[]\n  to: NodeUnit | NodeUnit[]\n  meta?: Record<string, any>\n}): Subscription => {\n  const METHOD = 'forward'\n  const [{from, to}, config] = processArgsToConfig(opts, true)\n  const errorTitle = generateErrorTitle(METHOD, config)\n  deprecate(false, METHOD, 'sample', errorTitle)\n  assertNodeSet(from, errorTitle, '\"from\"')\n  assertNodeSet(to, errorTitle, '\"to\"')\n  assertTarget(errorTitle, to, 'to')\n  return createSubscription(\n    createNode({\n      parent: from,\n      child: to,\n      meta: {op: METHOD, config},\n      family: {},\n      regional: true,\n    }),\n  )\n}\n","import {run} from './step'\nimport {callStack} from './caller'\nimport {createNode} from './createNode'\nimport {Subscription, NodeUnit} from './index.h'\nimport {createSubscription} from './subscription'\nimport {assert} from './throw'\nimport {isFunction} from './is'\n\nexport const watchUnit = (\n  unit: NodeUnit,\n  handler: (payload: any) => any,\n): Subscription => {\n  assert(isFunction(handler), '.watch argument should be a function')\n  return createSubscription(\n    createNode({\n      scope: {fn: handler},\n      node: [run({fn: callStack})],\n      parent: unit,\n      meta: {op: 'watch'},\n      family: {owners: unit},\n      regional: true,\n    }),\n  )\n}\n"],"names":["forIn","obj","cb","key","forEach","list","fn","assert","condition","message","errorTitle","Error","withRegion","unit","meta","getGraph","regionStack","id","parent","value","template","readTemplate","sidRoot","reportDeclaration","getParent","createNode","node","from","source","to","target","child","scope","family","familyRaw","type","regional","sources","arrifyNodes","links","owners","seq","item","add","result","nextNodeID","next","link","getOwners","owner","getLinks","own","getValue","launch","payload","upsert","pageForLaunch","currentPage","stackForLaunch","forkPageForLaunch","forkPage","params","defer","page","stack","getForkPage","Array","isArray","i","length","pushFirstHeapItem","isRoot","lastStartedState","isWatch","isPure","stop","skip","reg","kernelLoop","deleteMin","idx","hasPageReg","hasScopeReg","local","fail","stepn","step","order","priority","barrierID","fullID","barriers","has","pushHeap","delete","data","store","pageForRef","getPageForRef","initRefInScope","softRead","undefined","readRef","getPageRef","current","op","pure","computationResult","safe","tryRun","filter","inspector","finalValue","nextNode","needFxCounter","fxCount","storeChange","warnSerialize","warnSerializeNode","additionalLinks","unitObjectName","objOrArr","method","name","comma","is","getCompositeName","fullName","toString","setStoreName","rawName","shortName","Object","assign","createName","path","composite","concat","generateErrorTitle","metadata","named","loc","file","line","column","processArgsToConfig","args","singleArgument","rawConfig","assertObject","or","childConfig","and","unwrappedNestedValue","isObject","nested","addUnsubscribe","callback","subscription","unsubscribe","applyTemplate","handlers","createEvent","nameOrConfig","maybeConfig","config","flattenConfig","event","getMeta","oldPage","setCurrentPage","create","callCreate","finalEvent","graphite","initUnit","actualOp","watch","watchUnit","map","deriveEvent","userFnCall","callStack","filterMap","calc","isVoid","prepend","targetable","contramapped","createLinkNode","applyParentHook","domain","hooks","setMeta","on","methodName","nodeSet","assertNodeSet","isFunction","deprecate","trigger","off","getSubscribers","set","createSubscription","updateStore","callARegStack","createStore","defaultState","props","plainState","createStateRef","updates","derived","plainStateId","explicitSkipVoid","voidValueAllowed","skipVoid","subscribers","Map","stateRef","getState","reachedPage","targetRef","setState","state","reset","units","currentSubscription","get","outerConfig","mapConfig","lastResult","storeState","parentStateVoid","innerStore","linkNode","addRefOp","getStoreState","noInit","eventOrFn","updateFilter","defaultConfig","upd","_","b","read","a","isVoidUpdate","console","error","requireExplicitSkipVoidMessage","callStackAReg","mov","serializeMeta","ignored","sid","isVoidDefaultState","reinit","combine","handler","stores","maybeExtConfig","isExtendedConfig","extConfig","rawHandler","structStoreShape","shapeReady","noArraySpread","slice","storeCombination","createDefer","req","Promise","rs","rj","catch","createEffect","instance","kind","use","runner","getCurrent","anyway","finally","done","status","doneData","failData","compositeName","scope_","scopeHandler","unitMap","sidMap","runnerFn","onResolve","onSettled","onReject","ok","runFn","then","fx","fxID","nextEffectID","savedFork","setForkPage","inFlight","serialize","x","pending","amount","effect","attach","injected","mapParams","attached","runnerSteps","runnerFnStep","sourceData","isEffectHandler","computedParams","splice","parentDomain","createApi","setters","createDomain","history","Event","Effect","Store","Domain","factory","tag","lowerCaseTag","toLowerCase","onCreateUnit","Set","ownerSet","hook","fromObservable","observable","observableItem","observableSymbol","subscribe","disposer","complete","merge","validateSampleConfig","atLeastOneFieldExists","sampleConfigFields","field","fieldErrorMessage","sample","clock","batch","greedy","createSampling","guard","restore","split","METHOD","targets","match","configForm","cases","matchIsUnit","matchIsFunction","matchIsShape","assertTarget","__","values","caseNames","keys","splitterSeq","compute","scopeTargets","String","launchCase","includes","lastValues","needBarrier","storeOrFn","updater","storeRef","caseName","splitterNode","allSettled","start","ctx","reject","parentFork","defers","launchUnits","launchParams","traverseStores","root","needSidlessStores","visit","normalizeValues","assertEach","mapOrRecordValues","hasSidDoubles","fork","domainOrConfig","optionalConfig","forkInFlightCounter","resolve","storeStack","storeNode","isNotCombineNode","sidIdMap","sidSerializeSettings","ignore","write","resultScope","cloneOf","idMap","createScope","fromSerialize","hydrate","valuesSidList","getOwnPropertyNames","storesRefIdMap","storeNodes","storeValues","traverseTarget","needToAssign","serializer","scopeBind","targetForkPage","restoreLastForkPage","lastForkPage","final","failed","err","ignoredStores","serializeSettings","noopSerializer","onlyChanges","createWatch","run","unshift","unsubs","scopeLinks","u","prepareSeq","watchOp","push","indexOf","clearNode","Symbol","graph","val","removeItem","pos","subject","suggestion","idCount","nextUnitID","nextStepID","reporter","setGraphInspector","readSidRoot","withFactory","ownerUnit","_link","flat","assertNodeSetItem","valueName","reason","targetField","cmd","nextBarrierID","isEffect","toStack","samplerPriority","isFilter","initial","ref","before","heap","ret","v","getPriority","r","l","queue","ix","first","last","size","bucket","t","newForkPage","newPage","isGetState","setInspector","newInspector","noopParser","sourceRef","isKernelCall","refsMap","_sourceRef$meta","isFresh","failReason","part","removeFromNode","currentNode","targetNode","clearNodeNormalized","deep","isDomainUnit","pop","clearMap","clear","events","effects","domains","scopeFn","forward","opts","hookType","isDomain","unitId","getType","observer","nativeTemplate","mapped","caller","reader","needSpread","clone","stateNew","rawShape","storeStateRef","rawShapeReader","softReader","c","childRef","defaultShape","computedValue","sidechain","targetMayBeStore","filterRequired","isUpward","sourceIsClock","filterType","clockState","filterNodes","filterRef","hasFilter","isFilterStore","syncSourceState","readAndFilter","jointNodeSeq","hasSource","isSourceStore","jointNode","src","joint","isCombine"],"mappings":"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"}