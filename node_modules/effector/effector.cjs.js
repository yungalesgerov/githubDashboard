function e(e,t){for(const r in e)t(e[r],r)}function t(e,t){e.forEach(t)}function r(e,t,r){if(!e)throw Error(`${r?r+': ':''}${t}`)}function n(e,t){const r=M(e).meta||{};ee={id:M(e).id,parent:ee,value:e,template:r.template||re(),sidRoot:r.sidRoot||ee&&ee.sidRoot,meta:r};try{return t()}finally{te('region'),ee=C(ee)}}function a({node:e=[],from:r,source:n,parent:a=r||n,to:o,target:s,child:i=o||s,scope:c={},meta:l={},family:d={type:'regular'},regional:u}={}){const p=oe(a),f=oe(d.links),m=oe(d.owners),h=[];t(e,(e=>e&&H(h,e)));const g={id:X(),seq:h,next:oe(i),meta:l,scope:c,family:{type:d.type||"crosslink",links:f,owners:m}};return t(f,(e=>H($(e),g))),t(m,(e=>H(z(e),g))),t(p,(e=>H(e.next,g))),u&&ee&&ae(N(ee),[g]),g}function o(e,r,n){let a,o=Te,s=null,i=_e;if(e.target&&(r=e.params,n=e.defer,a=e.meta,o='page'in e?e.page:o,e.stack&&(s=e.stack),i=I(e)||i,e=e.target),i&&_e&&i!==_e&&(_e=null),Array.isArray(e))for(let t=0;t<e.length;t++)Re('pure',o,M(e[t]),s,r[t],i,a);else Re('pure',o,M(e),s,r,i,a);if(n&&!Pe)return;const c={isRoot:Pe,currentPage:Te,scope:_e,isWatch:Ee,isPure:Ve};let l,d,u,p,f,m;Pe=0;e:for(;p=Oe();){const{idx:e,stack:r,type:n}=p;u=r.node,Te=f=r.page,_e=I(r),f?m=f.reg:_e&&(m=_e.reg);const a=!!f,o=!!_e,s={fail:0,scope:u.scope};l=d=0;for(let t=e;t<u.seq.length&&!l;t++){const i=u.seq[t];if(i.order){const{priority:a,barrierID:o}=i.order,s=o?f?`${f.fullID}_${o}`:o:0;if(t!==e||n!==a){o?qe.has(s)||(qe.add(s),Fe(t,r,a,o)):Fe(t,r,a,0);continue e}o&&qe.delete(s)}switch(i.type){case'mov':{const e=i.data;let t;switch(e.from){case'stack':t=N(r);break;case'a':case'b':t=r[e.from];break;case'value':t=e.store;break;case'store':if(m&&!m[e.store.id])if(a){const t=We(f,e.store.id);r.page=f=t,t?m=t.reg:o?(Je(_e,e.store,0,1,e.softRead),m=_e.reg):m=void 0}else o&&Je(_e,e.store,0,1,e.softRead);t=ze(m&&m[e.store.id]||e.store)}switch(e.to){case'stack':r.value=t;break;case'a':case'b':r[e.to]=t;break;case'store':Ge(f,_e,e.target,0).current=t}break}case'compute':const e=i.data;if(e.fn){Ee='watch'===u.meta.op,Ve=e.pure;const t=e.safe?(0,e.fn)(N(r),s.scope,r):Ke(s,e.fn,r);e.filter?d=!t:r.value=t,Ee=c.isWatch,Ve=c.isPure}}l=s.fail||d}if(He&&He(r,s),!l){const e=N(r),n=I(r);if(t(u.next,(t=>{Re('child',f,t,r,e,n)})),n){u.meta.needFxCounter&&Re('child',f,n.fxCount,r,e,n),u.meta.storeChange&&Re('child',f,n.storeChange,r,e,n),u.meta.warnSerialize&&Re('child',f,n.warnSerializeNode,r,e,n);const a=n.additionalLinks[u.id];a&&t(a,(t=>{Re('child',f,t,r,e,n)}))}}}Pe=c.isRoot,Te=c.currentPage,_e=I(c)}function s(t,r="combine"){let n=r+'(',a='',o=0;return e(t,(e=>{o<25&&(null!=e&&(n+=a,n+=D(e)?F(e).fullName:e.toString()),o+=1,a=', ')})),n+')'}function i(e,t){let r,n;const a=e;if(t){const a=F(t);0===e.length?(r=a.path,n=a.fullName):(r=a.path.concat([e]),n=0===a.fullName.length?e:a.fullName+'/'+e)}else r=0===e.length?[]:[e],n=e;return{shortName:a,fullName:n,path:r}}function c(e,t){if(!t)return e;if(!t.name&&!t.named&&!t.loc)return e;let r=`[${e}]`;const n=t.named||t.name;n&&(r+=` unit '${n}'`);const a=t.loc;return!n&&a&&(r+=` (${a.file}:${a.line}:${a.column})`),r}function l(e,t){const r=t?e:e[0];le(r);let n=r.or;const a=r.and;if(a){const r=t?a:a[0];if(se(r)&&'and'in r){const r=l(a,t);e=r[0],n={...n,...r[1]}}else e=a}return[e,n]}function d(e){const t=()=>e();return t.unsubscribe=()=>e(),t}function u(e,...t){const r=re();if(r){const n=r.handlers[e];if(n)return n(r,...t)}}function p(e,t){const n=Qe({or:t,and:'string'==typeof e?{name:e}:e}),s=c('event',n),i=(e,...t)=>(r(!O(i,'derived'),'call of derived event is not supported, use createEvent instead',s),r(!Ve,'unit call from pure function is not supported, use operators like sample instead',s),Te?((e,t,r,n)=>{const a=Te;let o=null;if(t)for(o=Te;o&&o.template!==t;)o=C(o);Le(o);const s=e.create(r,n);return Le(a),s})(i,l,e,t):i.create(e,t)),l=re(),d=Object.assign(i,{graphite:a({meta:ot(n.actualOp||"event",i,n),regional:1}),create:e=>(o({target:i,params:e,scope:_e}),e),watch:e=>nt(i,e),map:e=>st(i,"map",e,[Se()]),filter:e=>st(i,'filter',e.fn?e:e.fn,[Se(he,1)]),filterMap:e=>st(i,'filterMap',e,[Se(),xe((e=>!ce(e)),1)]),prepend(e){r(i.targetable,'.prepend of derived event is not supported, call source event instead',s);const t=p('* \u2192 '+i.shortName,{parent:C(i)});return u('eventPrepend',M(t)),rt(t,i,[Se()],'prepend',e),at(i,t),t}});return null!=n&&n.domain&&n.domain.hooks.event(d),R(d,'id',d.graphite.id),te(d.graphite),d}function f(e,n,a,o,s){return ue(a,`${s} ${n}`,'first argument'),r(ie(o),'second argument should be a function',s),U(!O(e,'derived'),`${n} in derived store`,`${n} in store created via createStore`,s),t(Array.isArray(a)?a:[a],(t=>{e.off(t),j(e).set(t,tt(lt(t,e,'on',me,o)))})),e}function m(e,n){const s=Qe(n),i=$e(e),l=c('store',s),d=p({named:'updates',derived:1});u('storeBase',i);const h=i.id,g='skipVoid'in s,y=g&&!s.skipVoid;U(!(g&&s.skipVoid),'{skipVoid: true}','updateFilter',l);const b={subscribers:new Map,updates:d,defaultState:e,stateRef:i,getState(){let e,t=i;if(Te){let t=Te;for(;t&&!t.reg[h];)t=C(t);t&&(e=t)}return!e&&_e&&(Je(_e,i,1),e=_e),e&&(t=e.reg[h]),ze(t)},setState:e=>o({target:b,params:e,defer:1,scope:_e}),reset:(...e)=>(r(b.targetable,'.reset of derived store is not supported',l),t(e,(e=>f(b,'.reset',e,(()=>b.defaultState),l))),b),on:(e,t)=>(r(b.targetable,'.on of derived store is not supported',l),f(b,'.on',e,t,l)),off(e){const t=j(b).get(e);return t&&(t(),j(b).delete(e)),b},map(e,t){let r,n;se(e)&&(r=e,e=e.fn);const a=b.getState(),o=ce(a);re()?n=null:(!o||o&&y)&&(n=e(a));const s=m(n,{name:`${b.shortName} \u2192 *`,derived:1,...t,and:r}),c=lt(b,s,"map",he,e);return Ae(A(s),{type:"map",fn:e,from:i}),A(s).noInit=1,u('storeMap',i,c),s},watch(e,t){if(U(!t,'watch second argument','sample',l),!t||!D(e)){const t=nt(b,e);return u('storeWatch',i,e)||e(b.getState()),t}return r(ie(t),'second argument should be a function',l),e.watch((e=>t(b.getState(),e)))}},v=ot("store",b,s),k=b.defaultConfig.updateFilter;b.graphite=a({scope:{state:i,fn:k},node:[xe(((e,t,r)=>(r.scope&&!r.scope.reg[i.id]&&(r.b=1),e))),we(i),xe(((e,t,{a:r,b:n})=>{const a=ce(e);return a&&!g&&console.error(`${l}: ${ct}`),(a&&y||!a)&&(e!==r||n)}),1),k&&Se(fe,1),be({from:"stack",target:i})],child:d,meta:{...v,defaultState:e},regional:1}),R(b,'id',b.graphite.id),R(b,'rootStateRefId',h);const x=O(b,'serialize'),w=O(b,'derived'),S='ignore'===x,M=O(b,'sid');M&&(R(b,'storeChange',1),i.sid=M),M||S||w||R(b,'warnSerialize',1);const $=ce(e);return r(w||!$||$&&y,ct,l),w&&$&&!g&&console.error(`${l}: ${ct}`),ae(b,[d]),null!=s&&s.domain&&s.domain.hooks.store(b),w||(b.reinit=p({named:'reinit'}),b.reset(b.reinit)),i.meta=b.graphite.meta,te(b.graphite),b}function h(...e){let t,n,a;[e,a]=l(e);const o=c('combine',a),s=e[e.length-1],i=e.length>1&&!_(s)&&se(s),d=i&&s,u=i?e[e.length-2]:s;let p,f,m;if(ie(u)?(n=e.slice(0,i?-2:-1),t=u):n=e,1===n.length){const e=n[0];_(e)||(p=e,f=1)}if(!f&&(p=n,t)){m=1;const e=t;t=t=>e(...t)}return r(se(p),`${o}: shape should be an object`),dt(Array.isArray(p),!m,p,a,t,d)}function g(){const e={};return e.req=new Promise(((t,r)=>{e.rs=t,e.rj=r})),e.req.catch((()=>{})),e}function y(e,t={}){const n=Qe(ie(e)?{handler:e}:e,t),s=c('effect',n),i=p(ie(e)?{handler:e}:e,{...t,actualOp:"effect"}),l=M(i);R(l,'op',i.kind="effect"),i.use=e=>(r(ie(e),'.use argument should be a function',s),b.scope.handler=e,i),i.use.getCurrent=()=>b.scope.handler;const d=i.finally=p({named:'finally',derived:1}),u=i.done=d.filterMap({named:'done',fn({status:e,params:t,result:r}){if('done'===e)return{params:t,result:r}}}),f=i.fail=d.filterMap({named:'fail',fn({status:e,params:t,error:r}){if('fail'===e)return{params:t,error:r}}}),h=i.doneData=u.map({named:'doneData',fn:({result:e})=>e}),y=i.failData=f.map({named:'failData',fn:({error:e})=>e}),b=a({scope:{handler:i.defaultConfig.handler||(()=>r(0,`no handler used in ${i.compositeName.fullName}`))},node:[xe(((e,t,r)=>{let n=t.handler;const a=I(r);if(a){const e=a.handlers.unitMap.get(i)||a.handlers.sidMap[i.sid];e&&(n=e)}return e.handler=n,e}),0,1),xe(((e,t,r)=>{if(t.runnerFn&&!t.runnerFn(e,null,r))return;const{params:n,req:a,handler:o,args:s=[n]}=e,i=pt(n,a,1,d,r),c=pt(n,a,0,d,r),[l,u]=ut(o,c,s);l&&(se(u)&&ie(u.then)?u.then(i,c):i(u))}),0,1)],meta:{op:'fx',fx:'runner'}});l.scope.runner=b,H(l.seq,xe(((e,{runner:t},r)=>{const n=C(r)?{params:e,req:{rs(e){},rj(e){}}}:e;return r.meta||(r.meta={fxID:Y()}),o({target:t,params:n,defer:1,scope:I(r),meta:r.meta}),n.params}))),i.create=e=>{const t=g(),r={params:e,req:t};if(_e&&!Ee){const e=_e;t.req.finally((()=>{Be(e)})).catch((()=>{}))}return o({target:i,params:r,scope:_e}),t.req};const v=i.inFlight=m(0,{serialize:'ignore',named:(O(i,'name')||i.graphite.id)+'.inFlight'}).on(i,(e=>e+1)).on(d,(e=>e-1)).map({fn:e=>e,named:'inFlight'});R(d,'needFxCounter','dec'),R(i,'needFxCounter',1);const k=i.pending=v.map({fn:e=>e>0,named:'pending'});return ae(i,[d,u,f,h,y,k,v]),null!=n&&n.domain&&n.domain.hooks.effect(i),i}function b(e,t){const r=c('merge',t);ue(e,r,'first argument');const n=p({name:s(e,'merge'),derived:1,and:t});return rt(e,n,[],'merge'),n}function v(e,n){let a=0;return t(mt,(t=>{t in e&&(r(null!=e[t],ht(n,t)),a=1)})),a}function k(e,r,n){const a=[];(function e(o){W(a,o)||(H(a,o),"store"===O(o,'op')&&(n||O(o,'sid'))&&r(o,O(o,'sid')),t(o.next,e),t($(o),e),t(z(o),e))})(e)}function x(e,n){const a=Array.isArray(e)?new Map(e):e,o=new Map;let s=0;if(a instanceof Map){const e={};return t(a,((t,a)=>{r(D(a),'Map key should be a unit'),n&&n(a,t),a.sid&&(a.sid in e&&(s=1),e[a.sid]=t),o.set(a,t)})),{sidMap:e,unitMap:o,hasSidDoubles:s}}return{sidMap:a,unitMap:o}}function w(e,t){return _(t)?[Me.mov({store:t.stateRef,to:'stack'}),...e]:e}Object.defineProperty(exports,'__esModule',{value:1});const S='undefined'!=typeof Symbol&&Symbol.observable||'@@observable',M=e=>e.graphite||e,$=e=>e.family.owners,z=e=>e.family.links,A=e=>e.stateRef,N=e=>e.value,j=e=>e.subscribers,C=e=>e.parent,I=e=>e.scope,O=(e,t)=>M(e).meta[t],R=(e,t,r)=>M(e).meta[t]=r,F=e=>e.compositeName,D=e=>(ie(e)||se(e))&&'kind'in e,q=e=>t=>D(t)&&t.kind===e,_=q("store"),P=q("event"),E=q("effect"),V=e=>D(e)&&!!e.targetable,T=q("domain"),B=q("scope");var L={__proto__:null,unit:D,store:_,event:P,effect:E,targetable:V,domain:T,scope:B,attached:e=>E(e)&&1==O(e,'attached')};const W=(e,t)=>e.includes(t),G=(e,t)=>{const r=e.indexOf(t);-1!==r&&e.splice(r,1)},H=(e,t)=>e.push(t),U=(e,t,r,n)=>!e&&console.error(`${n?n+': ':''}${t} is deprecated${r?`, use ${r} instead`:''}`),J=()=>{let e=0;return()=>""+ ++e},K=J(),Q=J(),X=J(),Y=J();let Z,ee=null;const te=e=>{Z&&Z(e,ee)},re=()=>ee&&ee.template,ne=e=>(e&&ee&&ee.sidRoot&&(e=`${ee.sidRoot}|${e}`),e),ae=(e,r)=>{const n=M(e);t(r,(e=>{const t=M(e);"domain"!==n.family.type&&(t.family.type="crosslink"),H($(t),n),H(z(n),t)}))},oe=(e=[])=>(Array.isArray(e)?e:[e]).flat().map(M),se=e=>'object'==typeof e&&null!==e,ie=e=>'function'==typeof e,ce=e=>void 0===e,le=e=>r(se(e)||ie(e),'expect first argument be an object'),de=(e,t,n,a)=>r(!(!se(e)&&!ie(e)||!('family'in e)&&!('graphite'in e)),`${t}: expect ${n} to be a unit (store, event or effect)${a}`),ue=(e,r,n)=>{Array.isArray(e)?t(e,((e,t)=>de(e,r,`${t} item of ${n}`,''))):de(e,r,n,' or array of units')},pe=(e,n,a="target")=>t(oe(n),(t=>r(!O(t,'derived'),`${e}: derived unit in "${a}" is not supported, use createStore/createEvent instead"`))),fe=(e,{fn:t},{a:r})=>t(e,r),me=(e,{fn:t},{a:r})=>t(r,e),he=(e,{fn:t})=>t(e),ge=(e,t,r,n)=>{const a={id:Q(),type:e,data:t};return r&&(a.order={priority:r},n&&(a.order.barrierID=++ye)),a};let ye=0;const be=({from:e="store",store:t,target:r,to:n=(r?"store":"stack"),batch:a,priority:o})=>ge('mov',{from:e,store:t,to:n,target:r},o,a),ve=({fn:e,batch:t,priority:r,safe:n=0,filter:a=0,pure:o=0})=>ge('compute',{fn:e,safe:n,filter:a,pure:o},r,t),ke=({fn:e})=>ve({fn:e,priority:"effect"}),xe=(e,t,r)=>ve({fn:e,safe:1,filter:t,priority:r&&"effect"}),we=(e,t,r)=>be({store:e,to:t?"stack":"a",priority:r&&"sampler",batch:1}),Se=(e=he,t)=>ve({fn:e,pure:1,filter:t}),Me={mov:be,compute:ve,filter:({fn:e,pure:t})=>ve({fn:e,filter:1,pure:t}),run:ke},$e=e=>({id:Q(),current:e,initial:e}),ze=({current:e})=>e,Ae=(e,t)=>{e.before||(e.before=[]),H(e.before,t)};let Ne=null;const je=(e,t)=>{if(!e)return t;if(!t)return e;let r;return(e.v.type===t.v.type&&e.v.id>t.v.id||De(e.v.type)>De(t.v.type))&&(r=e,e=t,t=r),r=je(e.r,t),e.r=e.l,e.l=r,e},Ce=[];let Ie=0;for(;Ie<6;)H(Ce,{first:null,last:null,size:0}),Ie+=1;const Oe=()=>{for(let e=0;e<6;e++){const t=Ce[e];if(t.size>0){if(3===e||4===e){t.size-=1;const e=Ne.v;return Ne=je(Ne.l,Ne.r),e}1===t.size&&(t.last=null);const r=t.first;return t.first=r.r,t.size-=1,r.v}}},Re=(e,t,r,n,a,o,s)=>Fe(0,{a:null,b:null,node:r,parent:n,value:a,page:t,scope:o,meta:s},e,0),Fe=(e,t,r,n)=>{const a=De(r),o=Ce[a],s={v:{idx:e,stack:t,type:r,id:n},l:null,r:null};3===a||4===a?Ne=je(Ne,s):(0===o.size?o.first=s:o.last.r=s,o.last=s),o.size+=1},De=e=>{switch(e){case'child':return 0;case'pure':return 1;case'read':return 2;case'barrier':return 3;case'sampler':return 4;case'effect':return 5;default:return-1}},qe=new Set;let _e,Pe=1,Ee=0,Ve=0,Te=null;const Be=e=>{_e=e},Le=e=>{Te=e},We=(e,t)=>{if(e){for(;e&&!e.reg[t];)e=e.parent;if(e)return e}return null},Ge=(e,t,r,n)=>{const a=We(e,r.id);return a?a.reg[r.id]:t?(Je(t,r,n),t.reg[r.id]):r};let He;const Ue=e=>e,Je=(e,r,n,a,o)=>{const s=e.reg;if(s[r.id])return;const i=r.sid,c={id:r.id,current:r.initial,meta:r.meta};if(c.id in e.values.idMap)c.current=e.values.idMap[c.id];else if(i&&i in e.values.sidMap&&!(i in e.sidIdMap)){var l;const t=null==r||null===(l=r.meta)||void 0===l?void 0:l.serialize;c.current=(e.fromSerialize&&'ignore'!==t&&(null==t?void 0:t.read)||Ue)(e.values.sidMap[i])}else if(r.before&&!o){let o=0;const i=n||!r.noInit||a;t(r.before,(t=>{switch(t.type){case'map':{const r=t.from;if((r||t.fn)&&(r&&Je(e,r,n,a),i)){const e=r&&s[r.id].current;c.current=t.fn?t.fn(e):e}break}case'field':Je(e,t.from,n,a),o||(o=1,c.current=Array.isArray(c.current)?[...c.current]:{...c.current}),i&&(c.current[t.field]=s[s[t.from.id].id].current)}}))}i&&(e.sidIdMap[i]=r.id),s[r.id]=c},Ke=(e,t,r)=>{try{return t(N(r),e.scope,r)}catch(t){console.error(t),e.fail=1,e.failReason=t}},Qe=(t,r={})=>(se(t)&&(Qe(t.or,r),e(t,((e,t)=>{ce(e)||'or'===t||'and'===t||(r[t]=e)})),Qe(t.and,r)),r),Xe=(e,t)=>{G(e.next,t),G($(e),t),G(z(e),t)},Ye=(e,t,r)=>{let n;e.next.length=0,e.seq.length=0,e.scope=null;let a=z(e);for(;n=a.pop();)Xe(n,e),(t||r&&'sample'!==e.meta.op||"crosslink"===n.family.type)&&Ye(n,t,'on'!==n.meta.op&&r);for(a=$(e);n=a.pop();)Xe(n,e),r&&"crosslink"===n.family.type&&Ye(n,t,'on'!==n.meta.op&&r)},Ze=e=>e.clear(),et=(e,{deep:t}={})=>{let r=0;if(e.ownerSet&&e.ownerSet.delete(e),_(e))Ze(j(e));else if(T(e)){r=1;const t=e.history;Ze(t.events),Ze(t.effects),Ze(t.stores),Ze(t.domains)}Ye(M(e),!!t,r)},tt=e=>d((()=>et(e))),rt=(e,t,r,n,o)=>a({node:r,parent:e,child:t,scope:{fn:o},meta:{op:n},family:{owners:[e,t],links:t},regional:1}),nt=(e,t)=>(r(ie(t),'.watch argument should be a function'),tt(a({scope:{fn:t},node:[ke({fn:he})],parent:e,meta:{op:'watch'},family:{owners:e},regional:1}))),at=(e,t,r="event")=>{C(e)&&C(e).hooks[r](t)},ot=(e,t,r)=>{const n=Qe(r),a="domain"===e,o=K(),{sid:s=null,named:c=null,domain:l=null,parent:d=l}=n,u=c||n.name||(a?'':o),p=i(u,d),f={op:t.kind=e,name:t.shortName=u,sid:t.sid=ne(s),named:c,unitId:t.id=o,serialize:n.serialize,derived:n.derived,config:n};if(t.targetable=!n.derived,t.parent=d,t.compositeName=p,t.defaultConfig=n,t.getType=()=>(U(0,'getType','compositeName.fullName'),p.fullName),!a){t.subscribe=e=>(le(e),t.watch(ie(e)?e:t=>e.next&&e.next(t))),t[S]=()=>t;const e=re();e&&(f.nativeTemplate=e)}return f},st=(e,t,r,n)=>{let a;se(r)&&(a=r,r=r.fn);const o=p({name:`${e.shortName} \u2192 *`,derived:1,and:a});return rt(e,o,n,t,r),o},ct='undefined is used to skip updates. To allow undefined as a value provide explicit { skipVoid: false } option',lt=(e,t,r,n,a)=>{const o=A(t),s=be({store:o,to:"a",priority:'read'});"map"===r&&(s.data.softRead=1);const i=[s,Se(n)];return u('storeOnMap',o,i,_(e)&&A(e)),rt(e,t,i,r,a)},dt=(t,n,a,o,i,l)=>{const d=c('combine',o),p=t?e=>[...e]:e=>({...e}),f=t?[]:{},h=p(f),g=$e(h),y=$e(1);g.type=t?'list':'shape',g.noInit=1,u('combineBase',g,y);const b=m(h,{name:s(a),derived:1,...l,and:o}),v=A(b);v.noInit=1,R(b,'isCombine',1);const k=we(g);k.order={priority:'barrier'};const x=be({store:v,to:'b',priority:'read'});x.data.softRead=1;const w=[xe(((e,t,r)=>(r.scope&&!r.scope.reg[g.id]&&(r.c=1),e))),k,be({store:y,to:'b'}),xe(((e,{key:t},r)=>{if(r.c||e!==r.a[t])return n&&r.b&&(r.a=p(r.a)),r.a[t]=e,1}),1),be({from:"a",target:g}),be({from:"value",store:0,target:y}),be({from:"value",store:1,target:y,priority:'barrier',batch:1}),we(g,1,1),i&&Se(),x];if(e(a,((e,t)=>{if(!_(e))return r(!D(e)&&!ce(e),`combine expects a store in a field ${t}`,d),void(h[t]=f[t]=e);f[t]=e.defaultState,h[t]=e.getState();const n=rt(e,b,w,'combine',i);n.scope.key=t;const a=A(e);Ae(g,{type:'field',field:t,from:a}),u('combineField',a,n)})),b.defaultShape=a,Ae(v,{type:"map",from:g,fn:i}),!re())if(i){const e=i(h);!ce(e)||l&&'skipVoid'in l||console.error(`${d}: ${ct}`),v.current=e,v.initial=e,b.defaultState=e}else b.defaultState=f;return b},ut=(e,t,r)=>{try{return[1,e(...r)]}catch(e){return t(e),[0,null]}},pt=(e,t,r,n,a)=>s=>{o({target:[n,ft],params:[r?{status:'done',params:e,result:s}:{status:'fail',params:e,error:s},{value:s,fn:r?t.rs:t.rj}],defer:1,page:a.page,scope:a.scope,meta:a.meta})},ft=a({node:[ke({fn:({fn:e,value:t})=>e(t)})],meta:{op:'fx',fx:'sidechain'}}),mt=['source','clock','target'],ht=(e,t)=>e+`: ${t} should be defined`,gt=(e,t,n,a,o,s,i,l,d,f,g,y)=>{const v=c(e,l),k=!!o;r(!ce(n)||!ce(t),ht(v,'either source or clock'));let x=0;ce(n)?x=1:D(n)||(n=h(n)),ce(t)?t=n:(ue(t,v,'clock'),Array.isArray(t)&&(t=b(t))),x&&(n=t),l||i||(i=n.shortName);let w='none';(g||a)&&(D(a)?w='unit':(r(ie(a),'`filter` should be function or unit'),w='fn')),o?(ue(o,v,'target'),pe(v,o)):'none'===w&&f&&_(n)&&_(t)?o=m(s?s(ze(A(n)),ze(A(t))):ze(A(n)),{name:i,sid:y,or:l}):(o=p({name:i,derived:1,or:l}),u('sampleTarget',M(o)));const S=$e();let $=[];if('unit'===w){const[r,n,s]=bt(a,o,t,S,e);s||$.push(...yt(n)),$.push(...yt(r))}const z=[];if(x)d&&z.push(we(S,1,1));else{const[r,a,s]=bt(n,o,t,S,e);s||z.push(...yt(a)),z.push(we(r,1,d))}const N=rt(t,o,[u('sampleSourceLoader'),be({from:"stack",target:S}),...z,...$,we(S),'fn'===w&&Se(((e,t,{a:r})=>a(e,r)),1),s&&Se(fe),u('sampleSourceUpward',k)],e,s);return ae(n,[N]),Object.assign(N.meta,l,{joint:1}),o},yt=e=>[we(e),xe(((e,t,{a:r})=>r),1)],bt=(e,t,r,n,o)=>{const s=_(e),i=s?A(e):$e(),c=$e(s);return s||a({parent:e,node:[be({from:"stack",target:i}),be({from:"value",store:1,target:c})],family:{owners:[e,t,r],links:t},meta:{op:o},regional:1}),u('sampleSource',c,i,n),[i,c,s]},vt=(e,t,r,n)=>{const a=e[t];a&&o({target:a,params:Array.isArray(a)?a.map((()=>r)):r,defer:1,stack:n})},kt=e=>!e.node.meta.isCombine||e.parent&&'combine'!==e.parent.node.meta.op,xt=e=>e;exports.allSettled=(e,{scope:t,params:r}={})=>{if(!D(e))return Promise.reject(new Error('first argument should be unit'));if(!(E(e)||P(e)||_(e)||B(e)))return Promise.reject(new Error('first argument accepts only effects, events, stores or scopes'));if(B(e))t=e;else if(!V(e)){const t=c('allSettled',M(e).meta);return Promise.reject(Error(`${t}: unit should be targetable`))}const n=g();n.parentFork=_e;const{fxCount:a}=t;H(a.scope.defers,n);const s=[],i=[];return B(e)||(H(s,e),H(i,E(e)?{params:r,req:{rs(e){n.value={status:'done',value:e}},rj(e){n.value={status:'fail',value:e}}}}:r)),H(s,a),H(i,null),o({target:s,params:i,scope:t}),n.req},exports.attach=e=>{let t;[e,t]=l(e,1);const n=c('attach',t);let{source:a,effect:s,mapParams:d,domain:u}=e;E(s)&&r(ce(u),'`domain` can only be used with a plain function',n);const p=y(e,t);R(p,'attached',1);const{runner:f}=M(p).scope;let m;const g=(e,t,r)=>{const{params:n,req:s,handler:i}=e,c=p.finally,l=pt(n,s,0,c,r),u=r.a,f=E(i);let m,h=1;if(d?[h,m]=ut(d,l,[n,u]):m=a&&f?u:n,h){if(!f)return e.args=[u,m],1;o({target:i,params:{params:m,req:{rs:pt(n,s,1,c,r),rj:l}},page:r.page,defer:1,meta:r.meta})}};if(a){let e;f.scope.runnerFn=g,_(a)?(e=a,ae(e,[p])):(e=h(a),ae(p,[e])),m=[xe((e=>e),0,1),we(A(e))],delete f.seq[1].order}else m=[xe(g,1,1)];f.seq.splice(1,0,...m),p.use(s);const b=C(s);return b&&(Object.assign(F(p),i(p.shortName,b)),p.defaultConfig.parent=b),at(s,p,"effect"),p},exports.clearNode=et,exports.combine=h,exports.createApi=(...t)=>{let[[r,n],a]=l(t);const o={};return e(n,((e,t)=>{const n=o[t]=p(t,{parent:C(r),config:a});r.on(n,e),at(r,n)})),o},exports.createDomain=function r(n,s){const i=Qe({or:s,and:'string'==typeof n?{name:n}:n}),c=a({family:{type:"domain"},regional:1,parent:(null==i?void 0:i.domain)||(null==i?void 0:i.parent)}),l={history:{},graphite:c,hooks:{}};c.meta=ot("domain",l,{parent:(null==i?void 0:i.domain)||(null==i?void 0:i.parent),or:{...i,derived:1}}),e({Event:p,Effect:y,Store:m,Domain:r},((e,r)=>{const n=r.toLowerCase(),a=p({named:`on${r}`});l.hooks[n]=a;const s=new Set;l.history[`${n}s`]=s,a.create=e=>(o(a,e),e),H(M(a).seq,xe(((e,t,r)=>(r.scope=null,e)))),a.watch((e=>{ae(l,[e]),s.add(e),e.ownerSet||(e.ownerSet=s),C(e)||(e.parent=l)})),ae(l,[a]),l[`onCreate${r}`]=e=>(t(s,e),a.watch(e)),l[`create${r}`]=l[n]=(t,r)=>{const n=Qe({and:r,or:t});return null!=n&&n.domain?e(t,r):a(e(t,{parent:l,or:n}))}}));const d=C(l);return d&&e(l.hooks,((e,t)=>rt(e,d.hooks[t]))),null!=i&&i.domain&&i.domain.hooks.domain(l),l},exports.createEffect=y,exports.createEvent=p,exports.createNode=a,exports.createStore=m,exports.createWatch=({unit:e,fn:t,scope:r,batch:n})=>{const o=[Me.run({fn:e=>t(e)})];n&&o.unshift(Me.compute({priority:'sampler',batch:1})),_(e)&&o.unshift(Me.mov({store:e.stateRef,to:'stack'}));const s=Array.isArray(e)?e:[e];if(r){const e=[],t=r.additionalLinks;return s.forEach((r=>{const n=t[r.graphite.id]||[];t[r.graphite.id]=n;const s=a({node:w(o,r),meta:{watchOp:r.kind}});n.push(s),e.push((()=>{const e=n.indexOf(s);-1!==e&&n.splice(e,1),et(s)}))})),d((()=>{e.forEach((e=>e()))}))}{const e=a({node:o,parent:s,family:{owners:s}});return d((()=>{et(e)}))}},exports.fork=(e,n)=>{let o,s=e;T(e)&&(U(0,'fork(domain)','fork()'),o=e,s=n);const i=(e=>{const r=a({scope:{defers:[],inFlight:0,fxID:0},node:[xe(((e,t,r)=>{r.parent?'dec'===r.parent.node.meta.needFxCounter?t.inFlight-=1:(t.inFlight+=1,t.fxID+=1):t.fxID+=1})),ve({priority:"sampler",batch:1}),xe(((e,r)=>{const{defers:n,fxID:a}=r;r.inFlight>0||0===n.length||Promise.resolve().then((()=>{r.fxID===a&&t(n.splice(0,n.length),(e=>{Be(e.parentFork),e.rs(e.value)}))}))}),0,1)]}),n=a({node:[xe(((e,t,r)=>{const n=r.parent;if(n){const t=n.node;if(kt(n)){const n=I(r),a=t.meta.sid;n.sidIdMap[a]=t.scope.state.id,n.values.sidMap[a]=e;const o=t.meta.serialize;o&&n.sidSerializeSettings.set(a,'ignore'===o?{ignore:1}:{ignore:0,write:o.write})}}}))]}),o=a({node:[xe(((e,t,r)=>{const n=I(r);n&&r.parent&&kt(r.parent)&&(n.warnSerialize=1)}))]}),s={cloneOf:e,reg:{},values:{sidMap:{},idMap:{}},sidIdMap:{},sidSerializeSettings:new Map,getState(e){if('current'in e)return Ge(Te,s,e,0).current;const t=M(e);return Ge(Te,s,t.scope.state,1).current},kind:"scope",graphite:a({family:{type:"domain",links:[r,n,o]},meta:{unit:'fork'},scope:{forkInFlightCounter:r}}),additionalLinks:{},handlers:{sidMap:{},unitMap:new Map},fxCount:r,storeChange:n,warnSerializeNode:o};return s})(o);if(s){if(s.values){const{sidMap:e,unitMap:n,hasSidDoubles:a}=x(s.values,(e=>r(_(e)&&V(e),'Values map can contain only writable stores as keys')));Object.assign(i.values.sidMap,e),t(n,((e,t)=>{if(i.values.idMap[t.stateRef.id]=e,i.sidIdMap[O(t,'sid')]=t.stateRef.id,'ignore'===O(t,'serialize')){const e=O(t,'sid');i.sidSerializeSettings.set(e,{ignore:1})}})),i.fromSerialize=!(Array.isArray(s.values)||s.values instanceof Map),i.hasSidDoubles=a}s.handlers&&(U(s.handlers instanceof Map||Array.isArray(s.handlers),'object with handlers','array'),i.handlers=x(s.handlers,(e=>r(E(e),"Handlers map can contain only effects as keys"))))}return i},exports.forward=e=>{const t='forward',[{from:r,to:n},o]=l(e,1),s=c(t,o);return U(0,t,'sample',s),ue(r,s,'"from"'),ue(n,s,'"to"'),pe(s,n,'to'),tt(a({parent:r,child:n,meta:{op:t,config:o},family:{},regional:1}))},exports.fromObservable=e=>{le(e);const t=S in e?e[S]():e;r(t.subscribe,'expect observable to have .subscribe');const n=p(),a=tt(n);return t.subscribe({next:n,error:a,complete:a}),n},exports.guard=(...e)=>{let[[t,r],n]=l(e);const a=c('guard',n);return U(0,'guard','sample',a),r||(r=t,t=r.source),v(r,a),gt('guard',r.clock,t,r.filter,r.target,null,r.name,n,!r.greedy,0,1)},exports.hydrate=(e,{values:n})=>{r(se(n),'values property should be an object');const{sidMap:a,unitMap:s}=x(n),i=Object.getOwnPropertyNames(a),c={};t(s,((e,t)=>{c[t.stateRef.id]=t}));const l=[],d=[];let u,p,f;B(e)?(u=e,f=1,r(u.cloneOf,'scope should be created from domain'),U(0,'hydrate(fork(domain), { values })','fork({ values })'),p=M(u.cloneOf)):T(e)?(U(0,'hydrate(domain, { values })','fork({ values })'),p=M(e)):r(0,'first argument of hydrate should be domain or scope'),k(p,((e,t)=>{if(t&&W(i,t)){H(l,e);const r=O(e,'serialize');r&&'ignore'!==r&&(a[t]=r.read(a[t])),H(d,a[t])}else e.scope.state.id in c&&(H(l,e),H(d,s.get(c[e.scope.state.id])))}),1),o({target:l,params:d,scope:u}),f&&Object.assign(u.values.sidMap,a)},exports.is=L,exports.launch=o,exports.merge=b,exports.restore=(t,n,a)=>{const o=c('restore',a);if(r(!_(t),'restore($store) is not supported',o),P(t)||E(t)){const e=C(t),r=m(n,{parent:e,name:t.shortName,and:a});return rt(E(t)?t.doneData:t,r),e&&e.hooks.store(r),r}const s=Array.isArray(t)?[]:{};return e(t,((e,t)=>s[t]=_(e)?e:m(e,{name:t}))),s},exports.sample=(...e)=>{let t,r,n,a,[[o,s,i],d]=l(e),u=1;const p=c('sample',d);return ce(s)&&se(o)&&v(o,p)&&(s=o.clock,i=o.fn,'batch'in o?u=o.batch:(U(!('greedy'in o),'greedy in sample','batch',p),u=!o.greedy),a=o.filter,t=o.target,r=o.name,n=o.sid,o=o.source),gt('sample',s,o,a,t,i,r,d,u,1,0,n)},exports.scopeBind=(e,{scope:t,safe:n}={})=>{r(t||_e||n,'scopeBind: scope not found');const a=t||_e;return t=>{function r(){Be(s)}let n,o=0;const s=_e;Be(a);try{n=e(t)}catch(e){n=e,o=1}if(r(),o)throw n;return n instanceof Promise&&n.then(r,r),n}},exports.serialize=(t,n={})=>{t.warnSerialize&&console.error('There is a store without sid in this scope, its value is omitted'),r(!t.hasSidDoubles,'duplicate sid found in this scope');const a=n.ignore?n.ignore.map((({sid:e})=>e)):[],o={};return e(t.values.sidMap,((e,r)=>{var n;if(W(a,r))return;const s=t.sidIdMap[r],i=null!==(n=t.sidSerializeSettings.get(r))&&void 0!==n?n:{ignore:0,write:xt};i.ignore||(o[r]=(0,i.write)(s&&s in t.reg?t.reg[s].current:e))})),'onlyChanges'in n&&(U(0,'onlyChanges'),n.onlyChanges||(r(t.cloneOf,'scope should be created from domain'),k(M(t.cloneOf),((e,r)=>{r in o||W(a,r)||O(e,'isCombine')||'ignore'===O(e,'serialize')||(o[r]=t.getState(e))})))),o},exports.setGraphInspector=e=>{Z=e},exports.setInspector=e=>{He=e},exports.setStoreName=(e,t)=>{e.shortName=t,Object.assign(F(e),i(t,C(e)))},exports.split=(...t)=>{const n='split';let o,s,[[i,d],f]=l(t);const m=c(n,f),h=!d;h&&(o=i.cases,d=i.match,s=i.clock,i=i.source);const g=_(d),y=!D(d)&&ie(d),b=!g&&!y&&se(d);r(D(i),'source must be a unit',m),o||(o={}),h?e(o,((e,t)=>pe(m,e,`cases.${t}`))):(r(b,'match should be an object',m),e(d,((e,t)=>o[t]=p({derived:1,named:`cases.${t}`,and:f}))),o.__=p({derived:1,named:'cases.__',and:f}));const v=new Set([].concat(i,s||[],Object.values(o))),k=Object.keys(g||y?o:d);let x;if(g||y)g&&v.add(d),x=[g&&we(A(d),0,1),ve({safe:g,filter:1,pure:!g,fn(e,t,r){const n=String(g?r.a:d(e));vt(t,W(k,n)?n:'__',e,r)}})];else if(b){const t=$e({});t.type='shape';const r=[];let n;e(d,((e,a)=>{if(D(e)){n=1,H(r,a),v.add(e);const o=rt(e,[],[we(t),xe(((e,t,{a:r})=>r[a]=e))]);if(_(e)){t.current[a]=e.getState();const r=A(e);Ae(t,{from:r,field:a,type:'field'}),u('splitMatchStore',r,o)}}})),n&&u('splitBase',t),x=[n&&we(t,0,1),Se(((e,t,n)=>{for(let a=0;a<k.length;a++){const o=k[a];if(W(r,o)?n.a[o]:d[o](e))return void vt(t,o,e,n)}vt(t,'__',e,n)}),1)]}else r(0,'expect match to be unit, function or object');const w=a({meta:{op:n},parent:s?[]:i,scope:o,node:x,family:{owners:Array.from(v)},regional:1});if(s&&gt(n,s,i,null,w,null,n,f,0,0,0),!h)return o},exports.step=Me,exports.version="23.2.2",exports.withFactory=({sid:e,name:t,loc:r,method:o,fn:s})=>n(a({meta:{sidRoot:ne(e),sid:e,name:t,loc:r,method:o,type:'factory'}}),s),exports.withRegion=n;
//# sourceMappingURL=effector.cjs.js.map
