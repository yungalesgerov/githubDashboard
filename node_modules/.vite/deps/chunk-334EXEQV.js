// node_modules/effector/effector.mjs
function e(e2, t2) {
  for (const r2 in e2) t2(e2[r2], r2);
}
function t(e2, t2) {
  e2.forEach(t2);
}
function r(e2, t2, r2) {
  if (!e2) throw Error(`${r2 ? r2 + ": " : ""}${t2}`);
}
function n(e2, t2) {
  const r2 = E(e2).meta || {};
  ge = { id: E(e2).id, parent: ge, value: e2, template: r2.template || be(), sidRoot: r2.sidRoot || ge && ge.sidRoot, meta: r2 };
  try {
    return t2();
  } finally {
    ye("region"), ge = H(ge);
  }
}
function a({ node: e2 = [], from: r2, source: n2, parent: a2 = r2 || n2, to: o2, target: s2, child: i2 = o2 || s2, scope: c2 = {}, meta: l2 = {}, family: d2 = { type: "regular" }, regional: u2 } = {}) {
  const f2 = Se(a2), p2 = Se(d2.links), m2 = Se(d2.owners), h2 = [];
  t(e2, (e3) => e3 && ie(h2, e3));
  const g2 = { id: fe(), seq: h2, next: Se(i2), meta: l2, scope: c2, family: { type: d2.type || "crosslink", links: p2, owners: m2 } };
  return t(p2, (e3) => ie(V(e3), g2)), t(m2, (e3) => ie(T(e3), g2)), t(f2, (e3) => ie(e3.next, g2)), u2 && ge && we(B(ge), [g2]), g2;
}
function o(e2, r2, n2) {
  let a2, o2 = at, s2 = null, i2 = et;
  if (e2.target && (r2 = e2.params, n2 = e2.defer, a2 = e2.meta, o2 = "page" in e2 ? e2.page : o2, e2.stack && (s2 = e2.stack), i2 = U(e2) || i2, e2 = e2.target), i2 && et && i2 !== et && (et = null), Array.isArray(e2)) for (let t2 = 0; t2 < e2.length; t2++) Qe("pure", o2, E(e2[t2]), s2, r2[t2], i2, a2);
  else Qe("pure", o2, E(e2), s2, r2, i2, a2);
  if (n2 && !tt) return;
  const c2 = { isRoot: tt, currentPage: at, scope: et, isWatch: rt, isPure: nt };
  let l2, d2, u2, f2, p2, m2;
  tt = 0;
  e: for (; f2 = Ke(); ) {
    const { idx: e3, stack: r3, type: n3 } = f2;
    u2 = r3.node, at = p2 = r3.page, et = U(r3), p2 ? m2 = p2.reg : et && (m2 = et.reg);
    const a3 = !!p2, o3 = !!et, s3 = { fail: 0, scope: u2.scope };
    l2 = d2 = 0;
    for (let t2 = e3; t2 < u2.seq.length && !l2; t2++) {
      const i3 = u2.seq[t2];
      if (i3.order) {
        const { priority: a4, barrierID: o4 } = i3.order, s4 = o4 ? p2 ? `${p2.fullID}_${o4}` : o4 : 0;
        if (t2 !== e3 || n3 !== a4) {
          o4 ? Ze.has(s4) || (Ze.add(s4), Xe(t2, r3, a4, o4)) : Xe(t2, r3, a4, 0);
          continue e;
        }
        o4 && Ze.delete(s4);
      }
      switch (i3.type) {
        case "mov": {
          const e5 = i3.data;
          let t3;
          switch (e5.from) {
            case "stack":
              t3 = B(r3);
              break;
            case "a":
            case "b":
              t3 = r3[e5.from];
              break;
            case "value":
              t3 = e5.store;
              break;
            case "store":
              if (m2 && !m2[e5.store.id]) if (a3) {
                const t4 = ct(p2, e5.store.id);
                r3.page = p2 = t4, t4 ? m2 = t4.reg : o3 ? (pt(et, e5.store, 0, 1, e5.softRead), m2 = et.reg) : m2 = void 0;
              } else o3 && pt(et, e5.store, 0, 1, e5.softRead);
              t3 = Be(m2 && m2[e5.store.id] || e5.store);
          }
          switch (e5.to) {
            case "stack":
              r3.value = t3;
              break;
            case "a":
            case "b":
              r3[e5.to] = t3;
              break;
            case "store":
              lt(p2, et, e5.target, 0).current = t3;
          }
          break;
        }
        case "compute":
          const e4 = i3.data;
          if (e4.fn) {
            rt = "watch" === u2.meta.op, nt = e4.pure;
            const t3 = e4.safe ? (0, e4.fn)(B(r3), s3.scope, r3) : mt(s3, e4.fn, r3);
            e4.filter ? d2 = !t3 : r3.value = t3, rt = c2.isWatch, nt = c2.isPure;
          }
      }
      l2 = s3.fail || d2;
    }
    if (dt && dt(r3, s3), !l2) {
      const e4 = B(r3), n4 = U(r3);
      if (t(u2.next, (t2) => {
        Qe("child", p2, t2, r3, e4, n4);
      }), n4) {
        u2.meta.needFxCounter && Qe("child", p2, n4.fxCount, r3, e4, n4), u2.meta.storeChange && Qe("child", p2, n4.storeChange, r3, e4, n4), u2.meta.warnSerialize && Qe("child", p2, n4.warnSerializeNode, r3, e4, n4);
        const a4 = n4.additionalLinks[u2.id];
        a4 && t(a4, (t2) => {
          Qe("child", p2, t2, r3, e4, n4);
        });
      }
    }
  }
  tt = c2.isRoot, at = c2.currentPage, et = U(c2);
}
function s(t2, r2 = "combine") {
  let n2 = r2 + "(", a2 = "", o2 = 0;
  return e(t2, (e2) => {
    o2 < 25 && (null != e2 && (n2 += a2, n2 += Q(e2) ? K(e2).fullName : e2.toString()), o2 += 1, a2 = ", ");
  }), n2 + ")";
}
function i(e2, t2) {
  e2.shortName = t2, Object.assign(K(e2), c(t2, H(e2)));
}
function c(e2, t2) {
  let r2, n2;
  const a2 = e2;
  if (t2) {
    const a3 = K(t2);
    0 === e2.length ? (r2 = a3.path, n2 = a3.fullName) : (r2 = a3.path.concat([e2]), n2 = 0 === a3.fullName.length ? e2 : a3.fullName + "/" + e2);
  } else r2 = 0 === e2.length ? [] : [e2], n2 = e2;
  return { shortName: a2, fullName: n2, path: r2 };
}
function l(e2, t2) {
  if (!t2) return e2;
  if (!t2.name && !t2.named && !t2.loc) return e2;
  let r2 = `[${e2}]`;
  const n2 = t2.named || t2.name;
  n2 && (r2 += ` unit '${n2}'`);
  const a2 = t2.loc;
  return !n2 && a2 && (r2 += ` (${a2.file}:${a2.line}:${a2.column})`), r2;
}
function d(e2, t2) {
  const r2 = t2 ? e2 : e2[0];
  ze(r2);
  let n2 = r2.or;
  const a2 = r2.and;
  if (a2) {
    const r3 = t2 ? a2 : a2[0];
    if ($e(r3) && "and" in r3) {
      const r4 = d(a2, t2);
      e2 = r4[0], n2 = { ...n2, ...r4[1] };
    } else e2 = a2;
  }
  return [e2, n2];
}
function u(e2) {
  const t2 = () => e2();
  return t2.unsubscribe = () => e2(), t2;
}
function f(e2, ...t2) {
  const r2 = be();
  if (r2) {
    const n2 = r2.handlers[e2];
    if (n2) return n2(r2, ...t2);
  }
}
function p(e2, t2) {
  const n2 = ht({ or: t2, and: "string" == typeof e2 ? { name: e2 } : e2 }), s2 = l("event", n2), i2 = (e3, ...t3) => (r(!G(i2, "derived"), "call of derived event is not supported, use createEvent instead", s2), r(!nt, "unit call from pure function is not supported, use operators like sample instead", s2), at ? ((e4, t4, r2, n3) => {
    const a2 = at;
    let o2 = null;
    if (t4) for (o2 = at; o2 && o2.template !== t4; ) o2 = H(o2);
    st(o2);
    const s3 = e4.create(r2, n3);
    return st(a2), s3;
  })(i2, c2, e3, t3) : i2.create(e3, t3)), c2 = be(), d2 = Object.assign(i2, { graphite: a({ meta: xt(n2.actualOp || "event", i2, n2), regional: 1 }), create: (e3) => (o({ target: i2, params: e3, scope: et }), e3), watch: (e3) => $t(i2, e3), map: (e3) => zt(i2, "map", e3, [Ve()]), filter: (e3) => zt(i2, "filter", e3.fn ? e3 : e3.fn, [Ve(Oe, 1)]), filterMap: (e3) => zt(i2, "filterMap", e3, [Ve(), _e((e4) => !xe(e4), 1)]), prepend(e3) {
    r(i2.targetable, ".prepend of derived event is not supported, call source event instead", s2);
    const t3 = p("* → " + i2.shortName, { parent: H(i2) });
    return f("eventPrepend", E(t3)), wt(t3, i2, [Ve()], "prepend", e3), Mt(i2, t3), t3;
  } });
  return null != n2 && n2.domain && n2.domain.hooks.event(d2), J(d2, "id", d2.graphite.id), ye(d2.graphite), d2;
}
function m(e2, n2, a2, o2, s2) {
  return je(a2, `${s2} ${n2}`, "first argument"), r(Me(o2), "second argument should be a function", s2), ce(!G(e2, "derived"), `${n2} in derived store`, `${n2} in store created via createStore`, s2), t(Array.isArray(a2) ? a2 : [a2], (t2) => {
    e2.off(t2), W(e2).set(t2, kt(jt(t2, e2, "on", Ie, o2)));
  }), e2;
}
function h(e2, n2) {
  const s2 = ht(n2), i2 = Le(e2), c2 = l("store", s2), d2 = p({ named: "updates", derived: 1 });
  f("storeBase", i2);
  const u2 = i2.id, g2 = "skipVoid" in s2, y2 = g2 && !s2.skipVoid;
  ce(!(g2 && s2.skipVoid), "{skipVoid: true}", "updateFilter", c2);
  const b2 = { subscribers: /* @__PURE__ */ new Map(), updates: d2, defaultState: e2, stateRef: i2, getState() {
    let e3, t2 = i2;
    if (at) {
      let t3 = at;
      for (; t3 && !t3.reg[u2]; ) t3 = H(t3);
      t3 && (e3 = t3);
    }
    return !e3 && et && (pt(et, i2, 1), e3 = et), e3 && (t2 = e3.reg[u2]), Be(t2);
  }, setState: (e3) => o({ target: b2, params: e3, defer: 1, scope: et }), reset: (...e3) => (r(b2.targetable, ".reset of derived store is not supported", c2), t(e3, (e4) => m(b2, ".reset", e4, () => b2.defaultState, c2)), b2), on: (e3, t2) => (r(b2.targetable, ".on of derived store is not supported", c2), m(b2, ".on", e3, t2, c2)), off(e3) {
    const t2 = W(b2).get(e3);
    return t2 && (t2(), W(b2).delete(e3)), b2;
  }, map(e3, t2) {
    let r2, n3;
    $e(e3) && (r2 = e3, e3 = e3.fn);
    const a2 = b2.getState(), o2 = xe(a2);
    be() ? n3 = null : (!o2 || o2 && y2) && (n3 = e3(a2));
    const s3 = h(n3, { name: `${b2.shortName} → *`, derived: 1, ...t2, and: r2 }), c3 = jt(b2, s3, "map", Oe, e3);
    return We(L(s3), { type: "map", fn: e3, from: i2 }), L(s3).noInit = 1, f("storeMap", i2, c3), s3;
  }, watch(e3, t2) {
    if (ce(!t2, "watch second argument", "sample", c2), !t2 || !Q(e3)) {
      const t3 = $t(b2, e3);
      return f("storeWatch", i2, e3) || e3(b2.getState()), t3;
    }
    return r(Me(t2), "second argument should be a function", c2), e3.watch((e4) => t2(b2.getState(), e4));
  } }, v2 = xt("store", b2, s2), k2 = b2.defaultConfig.updateFilter;
  b2.graphite = a({ scope: { state: i2, fn: k2 }, node: [_e((e3, t2, r2) => (r2.scope && !r2.scope.reg[i2.id] && (r2.b = 1), e3)), Ee(i2), _e((e3, t2, { a: r2, b: n3 }) => {
    const a2 = xe(e3);
    return a2 && !g2 && console.error(`${c2}: ${At}`), (a2 && y2 || !a2) && (e3 !== r2 || n3);
  }, 1), k2 && Ve(Ne, 1), qe({ from: "stack", target: i2 })], child: d2, meta: { ...v2, defaultState: e2 }, regional: 1 }), J(b2, "id", b2.graphite.id), J(b2, "rootStateRefId", u2);
  const w2 = G(b2, "serialize"), S2 = G(b2, "derived"), $2 = "ignore" === w2, M2 = G(b2, "sid");
  M2 && (J(b2, "storeChange", 1), i2.sid = M2), M2 || $2 || S2 || J(b2, "warnSerialize", 1);
  const x2 = xe(e2);
  return r(S2 || !x2 || x2 && y2, At, c2), S2 && x2 && !g2 && console.error(`${c2}: ${At}`), we(b2, [d2]), null != s2 && s2.domain && s2.domain.hooks.store(b2), S2 || (b2.reinit = p({ named: "reinit" }), b2.reset(b2.reinit)), i2.meta = b2.graphite.meta, ye(b2.graphite), b2;
}
function g(...e2) {
  let t2, n2, a2;
  [e2, a2] = d(e2);
  const o2 = l("combine", a2), s2 = e2[e2.length - 1], i2 = e2.length > 1 && !Y(s2) && $e(s2), c2 = i2 && s2, u2 = i2 ? e2[e2.length - 2] : s2;
  let f2, p2, m2;
  if (Me(u2) ? (n2 = e2.slice(0, i2 ? -2 : -1), t2 = u2) : n2 = e2, 1 === n2.length) {
    const e3 = n2[0];
    Y(e3) || (f2 = e3, p2 = 1);
  }
  if (!p2 && (f2 = n2, t2)) {
    m2 = 1;
    const e3 = t2;
    t2 = (t3) => e3(...t3);
  }
  return r($e(f2), `${o2}: shape should be an object`), Ct(Array.isArray(f2), !m2, f2, a2, t2, c2);
}
function y() {
  const e2 = {};
  return e2.req = new Promise((t2, r2) => {
    e2.rs = t2, e2.rj = r2;
  }), e2.req.catch(() => {
  }), e2;
}
function b(e2, t2 = {}) {
  const n2 = ht(Me(e2) ? { handler: e2 } : e2, t2), s2 = l("effect", n2), i2 = p(Me(e2) ? { handler: e2 } : e2, { ...t2, actualOp: "effect" }), c2 = E(i2);
  J(c2, "op", i2.kind = "effect"), i2.use = (e3) => (r(Me(e3), ".use argument should be a function", s2), b2.scope.handler = e3, i2), i2.use.getCurrent = () => b2.scope.handler;
  const d2 = i2.finally = p({ named: "finally", derived: 1 }), u2 = i2.done = d2.filterMap({ named: "done", fn({ status: e3, params: t3, result: r2 }) {
    if ("done" === e3) return { params: t3, result: r2 };
  } }), f2 = i2.fail = d2.filterMap({ named: "fail", fn({ status: e3, params: t3, error: r2 }) {
    if ("fail" === e3) return { params: t3, error: r2 };
  } }), m2 = i2.doneData = u2.map({ named: "doneData", fn: ({ result: e3 }) => e3 }), g2 = i2.failData = f2.map({ named: "failData", fn: ({ error: e3 }) => e3 }), b2 = a({ scope: { handler: i2.defaultConfig.handler || (() => r(0, `no handler used in ${i2.compositeName.fullName}`)) }, node: [_e((e3, t3, r2) => {
    let n3 = t3.handler;
    const a2 = U(r2);
    if (a2) {
      const e4 = a2.handlers.unitMap.get(i2) || a2.handlers.sidMap[i2.sid];
      e4 && (n3 = e4);
    }
    return e3.handler = n3, e3;
  }, 0, 1), _e((e3, t3, r2) => {
    if (t3.runnerFn && !t3.runnerFn(e3, null, r2)) return;
    const { params: n3, req: a2, handler: o2, args: s3 = [n3] } = e3, i3 = It(n3, a2, 1, d2, r2), c3 = It(n3, a2, 0, d2, r2), [l2, u3] = Nt(o2, c3, s3);
    l2 && ($e(u3) && Me(u3.then) ? u3.then(i3, c3) : i3(u3));
  }, 0, 1)], meta: { op: "fx", fx: "runner" } });
  c2.scope.runner = b2, ie(c2.seq, _e((e3, { runner: t3 }, r2) => {
    const n3 = H(r2) ? { params: e3, req: { rs(e4) {
    }, rj(e4) {
    } } } : e3;
    return r2.meta || (r2.meta = { fxID: pe() }), o({ target: t3, params: n3, defer: 1, scope: U(r2), meta: r2.meta }), n3.params;
  })), i2.create = (e3) => {
    const t3 = y(), r2 = { params: e3, req: t3 };
    if (et && !rt) {
      const e4 = et;
      t3.req.finally(() => {
        ot(e4);
      }).catch(() => {
      });
    }
    return o({ target: i2, params: r2, scope: et }), t3.req;
  };
  const v2 = i2.inFlight = h(0, { serialize: "ignore", named: (G(i2, "name") || i2.graphite.id) + ".inFlight" }).on(i2, (e3) => e3 + 1).on(d2, (e3) => e3 - 1).map({ fn: (e3) => e3, named: "inFlight" });
  J(d2, "needFxCounter", "dec"), J(i2, "needFxCounter", 1);
  const k2 = i2.pending = v2.map({ fn: (e3) => e3 > 0, named: "pending" });
  return we(i2, [d2, u2, f2, m2, g2, k2, v2]), null != n2 && n2.domain && n2.domain.hooks.effect(i2), i2;
}
function v(e2) {
  let t2;
  [e2, t2] = d(e2, 1);
  const n2 = l("attach", t2);
  let { source: a2, effect: s2, mapParams: i2, domain: u2 } = e2;
  ee(s2) && r(xe(u2), "`domain` can only be used with a plain function", n2);
  const f2 = b(e2, t2);
  J(f2, "attached", 1);
  const { runner: p2 } = E(f2).scope;
  let m2;
  const h2 = (e3, t3, r2) => {
    const { params: n3, req: s3, handler: c2 } = e3, l2 = f2.finally, d2 = It(n3, s3, 0, l2, r2), u3 = r2.a, p3 = ee(c2);
    let m3, h3 = 1;
    if (i2 ? [h3, m3] = Nt(i2, d2, [n3, u3]) : m3 = a2 && p3 ? u3 : n3, h3) {
      if (!p3) return e3.args = [u3, m3], 1;
      o({ target: c2, params: { params: m3, req: { rs: It(n3, s3, 1, l2, r2), rj: d2 } }, page: r2.page, defer: 1, meta: r2.meta });
    }
  };
  if (a2) {
    let e3;
    p2.scope.runnerFn = h2, Y(a2) ? (e3 = a2, we(e3, [f2])) : (e3 = g(a2), we(f2, [e3])), m2 = [_e((e4) => e4, 0, 1), Ee(L(e3))], delete p2.seq[1].order;
  } else m2 = [_e(h2, 1, 1)];
  p2.seq.splice(1, 0, ...m2), f2.use(s2);
  const y2 = H(s2);
  return y2 && (Object.assign(K(f2), c(f2.shortName, y2)), f2.defaultConfig.parent = y2), Mt(s2, f2, "effect"), f2;
}
function k(...t2) {
  let [[r2, n2], a2] = d(t2);
  const o2 = {};
  return e(n2, (e2, t3) => {
    const n3 = o2[t3] = p(t3, { parent: H(r2), config: a2 });
    r2.on(n3, e2), Mt(r2, n3);
  }), o2;
}
function w(r2, n2) {
  const s2 = ht({ or: n2, and: "string" == typeof r2 ? { name: r2 } : r2 }), i2 = a({ family: { type: "domain" }, regional: 1, parent: (null == s2 ? void 0 : s2.domain) || (null == s2 ? void 0 : s2.parent) }), c2 = { history: {}, graphite: i2, hooks: {} };
  i2.meta = xt("domain", c2, { parent: (null == s2 ? void 0 : s2.domain) || (null == s2 ? void 0 : s2.parent), or: { ...s2, derived: 1 } }), e({ Event: p, Effect: b, Store: h, Domain: w }, (e2, r3) => {
    const n3 = r3.toLowerCase(), a2 = p({ named: `on${r3}` });
    c2.hooks[n3] = a2;
    const s3 = /* @__PURE__ */ new Set();
    c2.history[`${n3}s`] = s3, a2.create = (e3) => (o(a2, e3), e3), ie(E(a2).seq, _e((e3, t2, r4) => (r4.scope = null, e3))), a2.watch((e3) => {
      we(c2, [e3]), s3.add(e3), e3.ownerSet || (e3.ownerSet = s3), H(e3) || (e3.parent = c2);
    }), we(c2, [a2]), c2[`onCreate${r3}`] = (e3) => (t(s3, e3), a2.watch(e3)), c2[`create${r3}`] = c2[n3] = (t2, r4) => {
      const n4 = ht({ and: r4, or: t2 });
      return null != n4 && n4.domain ? e2(t2, r4) : a2(e2(t2, { parent: c2, or: n4 }));
    };
  });
  const l2 = H(c2);
  return l2 && e(c2.hooks, (e2, t2) => wt(e2, l2.hooks[t2])), null != s2 && s2.domain && s2.domain.hooks.domain(c2), c2;
}
function S(e2) {
  ze(e2);
  const t2 = _ in e2 ? e2[_]() : e2;
  r(t2.subscribe, "expect observable to have .subscribe");
  const n2 = p(), a2 = kt(n2);
  return t2.subscribe({ next: n2, error: a2, complete: a2 }), n2;
}
function $(e2, t2) {
  const r2 = l("merge", t2);
  je(e2, r2, "first argument");
  const n2 = p({ name: s(e2, "merge"), derived: 1, and: t2 });
  return wt(e2, n2, [], "merge"), n2;
}
function M(e2, n2) {
  let a2 = 0;
  return t(Rt, (t2) => {
    t2 in e2 && (r(null != e2[t2], Ft(n2, t2)), a2 = 1);
  }), a2;
}
function x(...e2) {
  let t2, r2, n2, a2, [[o2, s2, i2], c2] = d(e2), u2 = 1;
  const f2 = l("sample", c2);
  return xe(s2) && $e(o2) && M(o2, f2) && (s2 = o2.clock, i2 = o2.fn, "batch" in o2 ? u2 = o2.batch : (ce(!("greedy" in o2), "greedy in sample", "batch", f2), u2 = !o2.greedy), a2 = o2.filter, t2 = o2.target, r2 = o2.name, n2 = o2.sid, o2 = o2.source), qt("sample", s2, o2, a2, t2, i2, r2, c2, u2, 1, 0, n2);
}
function z(...e2) {
  let [[t2, r2], n2] = d(e2);
  const a2 = l("guard", n2);
  return ce(0, "guard", "sample", a2), r2 || (r2 = t2, t2 = r2.source), M(r2, a2), qt("guard", r2.clock, t2, r2.filter, r2.target, null, r2.name, n2, !r2.greedy, 0, 1);
}
function A(t2, n2, a2) {
  const o2 = l("restore", a2);
  if (r(!Y(t2), "restore($store) is not supported", o2), Z(t2) || ee(t2)) {
    const e2 = H(t2), r2 = h(n2, { parent: e2, name: t2.shortName, and: a2 });
    return wt(ee(t2) ? t2.doneData : t2, r2), e2 && e2.hooks.store(r2), r2;
  }
  const s2 = Array.isArray(t2) ? [] : {};
  return e(t2, (e2, t3) => s2[t3] = Y(e2) ? e2 : h(e2, { name: t3 })), s2;
}
function j(...t2) {
  const n2 = "split";
  let o2, s2, [[i2, c2], u2] = d(t2);
  const m2 = l(n2, u2), h2 = !c2;
  h2 && (o2 = i2.cases, c2 = i2.match, s2 = i2.clock, i2 = i2.source);
  const g2 = Y(c2), y2 = !Q(c2) && Me(c2), b2 = !g2 && !y2 && $e(c2);
  r(Q(i2), "source must be a unit", m2), o2 || (o2 = {}), h2 ? e(o2, (e2, t3) => Ce(m2, e2, `cases.${t3}`)) : (r(b2, "match should be an object", m2), e(c2, (e2, t3) => o2[t3] = p({ derived: 1, named: `cases.${t3}`, and: u2 })), o2.__ = p({ derived: 1, named: "cases.__", and: u2 }));
  const v2 = new Set([].concat(i2, s2 || [], Object.values(o2))), k2 = Object.keys(g2 || y2 ? o2 : c2);
  let w2;
  if (g2 || y2) g2 && v2.add(c2), w2 = [g2 && Ee(L(c2), 0, 1), De({ safe: g2, filter: 1, pure: !g2, fn(e2, t3, r2) {
    const n3 = String(g2 ? r2.a : c2(e2));
    _t(t3, oe(k2, n3) ? n3 : "__", e2, r2);
  } })];
  else if (b2) {
    const t3 = Le({});
    t3.type = "shape";
    const r2 = [];
    let n3;
    e(c2, (e2, a2) => {
      if (Q(e2)) {
        n3 = 1, ie(r2, a2), v2.add(e2);
        const o3 = wt(e2, [], [Ee(t3), _e((e3, t4, { a: r3 }) => r3[a2] = e3)]);
        if (Y(e2)) {
          t3.current[a2] = e2.getState();
          const r3 = L(e2);
          We(t3, { from: r3, field: a2, type: "field" }), f("splitMatchStore", r3, o3);
        }
      }
    }), n3 && f("splitBase", t3), w2 = [n3 && Ee(t3, 0, 1), Ve((e2, t4, n4) => {
      for (let a2 = 0; a2 < k2.length; a2++) {
        const o3 = k2[a2];
        if (oe(r2, o3) ? n4.a[o3] : c2[o3](e2)) return void _t(t4, o3, e2, n4);
      }
      _t(t4, "__", e2, n4);
    }, 1)];
  } else r(0, "expect match to be unit, function or object");
  const S2 = a({ meta: { op: n2 }, parent: s2 ? [] : i2, scope: o2, node: w2, family: { owners: Array.from(v2) }, regional: 1 });
  if (s2 && qt(n2, s2, i2, null, S2, null, n2, u2, 0, 0, 0), !h2) return o2;
}
function C(e2, { scope: t2, params: r2 } = {}) {
  if (!Q(e2)) return Promise.reject(new Error("first argument should be unit"));
  if (!(ee(e2) || Z(e2) || Y(e2) || ne(e2))) return Promise.reject(new Error("first argument accepts only effects, events, stores or scopes"));
  if (ne(e2)) t2 = e2;
  else if (!te(e2)) {
    const t3 = l("allSettled", E(e2).meta);
    return Promise.reject(Error(`${t3}: unit should be targetable`));
  }
  const n2 = y();
  n2.parentFork = et;
  const { fxCount: a2 } = t2;
  ie(a2.scope.defers, n2);
  const s2 = [], i2 = [];
  return ne(e2) || (ie(s2, e2), ie(i2, ee(e2) ? { params: r2, req: { rs(e3) {
    n2.value = { status: "done", value: e3 };
  }, rj(e3) {
    n2.value = { status: "fail", value: e3 };
  } } } : r2)), ie(s2, a2), ie(i2, null), o({ target: s2, params: i2, scope: t2 }), n2.req;
}
function N(e2, r2, n2) {
  const a2 = [];
  (function e3(o2) {
    oe(a2, o2) || (ie(a2, o2), "store" === G(o2, "op") && (n2 || G(o2, "sid")) && r2(o2, G(o2, "sid")), t(o2.next, e3), t(V(o2), e3), t(T(o2), e3));
  })(e2);
}
function I(e2, n2) {
  const a2 = Array.isArray(e2) ? new Map(e2) : e2, o2 = /* @__PURE__ */ new Map();
  let s2 = 0;
  if (a2 instanceof Map) {
    const e3 = {};
    return t(a2, (t2, a3) => {
      r(Q(a3), "Map key should be a unit"), n2 && n2(a3, t2), a3.sid && (a3.sid in e3 && (s2 = 1), e3[a3.sid] = t2), o2.set(a3, t2);
    }), { sidMap: e3, unitMap: o2, hasSidDoubles: s2 };
  }
  return { sidMap: a2, unitMap: o2 };
}
function O(e2, n2) {
  let o2, s2 = e2;
  re(e2) && (ce(0, "fork(domain)", "fork()"), o2 = e2, s2 = n2);
  const i2 = ((e3) => {
    const r2 = a({ scope: { defers: [], inFlight: 0, fxID: 0 }, node: [_e((e4, t2, r3) => {
      r3.parent ? "dec" === r3.parent.node.meta.needFxCounter ? t2.inFlight -= 1 : (t2.inFlight += 1, t2.fxID += 1) : t2.fxID += 1;
    }), De({ priority: "sampler", batch: 1 }), _e((e4, r3) => {
      const { defers: n4, fxID: a2 } = r3;
      r3.inFlight > 0 || 0 === n4.length || Promise.resolve().then(() => {
        r3.fxID === a2 && t(n4.splice(0, n4.length), (e5) => {
          ot(e5.parentFork), e5.rs(e5.value);
        });
      });
    }, 0, 1)] }), n3 = a({ node: [_e((e4, t2, r3) => {
      const n4 = r3.parent;
      if (n4) {
        const t3 = n4.node;
        if (Vt(n4)) {
          const n5 = U(r3), a2 = t3.meta.sid;
          n5.sidIdMap[a2] = t3.scope.state.id, n5.values.sidMap[a2] = e4;
          const o4 = t3.meta.serialize;
          o4 && n5.sidSerializeSettings.set(a2, "ignore" === o4 ? { ignore: 1 } : { ignore: 0, write: o4.write });
        }
      }
    })] }), o3 = a({ node: [_e((e4, t2, r3) => {
      const n4 = U(r3);
      n4 && r3.parent && Vt(r3.parent) && (n4.warnSerialize = 1);
    })] }), s3 = { cloneOf: e3, reg: {}, values: { sidMap: {}, idMap: {} }, sidIdMap: {}, sidSerializeSettings: /* @__PURE__ */ new Map(), getState(e4) {
      if ("current" in e4) return lt(at, s3, e4, 0).current;
      const t2 = E(e4);
      return lt(at, s3, t2.scope.state, 1).current;
    }, kind: "scope", graphite: a({ family: { type: "domain", links: [r2, n3, o3] }, meta: { unit: "fork" }, scope: { forkInFlightCounter: r2 } }), additionalLinks: {}, handlers: { sidMap: {}, unitMap: /* @__PURE__ */ new Map() }, fxCount: r2, storeChange: n3, warnSerializeNode: o3 };
    return s3;
  })(o2);
  if (s2) {
    if (s2.values) {
      const { sidMap: e3, unitMap: n3, hasSidDoubles: a2 } = I(s2.values, (e4) => r(Y(e4) && te(e4), "Values map can contain only writable stores as keys"));
      Object.assign(i2.values.sidMap, e3), t(n3, (e4, t2) => {
        if (i2.values.idMap[t2.stateRef.id] = e4, i2.sidIdMap[G(t2, "sid")] = t2.stateRef.id, "ignore" === G(t2, "serialize")) {
          const e5 = G(t2, "sid");
          i2.sidSerializeSettings.set(e5, { ignore: 1 });
        }
      }), i2.fromSerialize = !(Array.isArray(s2.values) || s2.values instanceof Map), i2.hasSidDoubles = a2;
    }
    s2.handlers && (ce(s2.handlers instanceof Map || Array.isArray(s2.handlers), "object with handlers", "array"), i2.handlers = I(s2.handlers, (e3) => r(ee(e3), "Handlers map can contain only effects as keys")));
  }
  return i2;
}
function R(e2, { values: n2 }) {
  r($e(n2), "values property should be an object");
  const { sidMap: a2, unitMap: s2 } = I(n2), i2 = Object.getOwnPropertyNames(a2), c2 = {};
  t(s2, (e3, t2) => {
    c2[t2.stateRef.id] = t2;
  });
  const l2 = [], d2 = [];
  let u2, f2, p2;
  ne(e2) ? (u2 = e2, p2 = 1, r(u2.cloneOf, "scope should be created from domain"), ce(0, "hydrate(fork(domain), { values })", "fork({ values })"), f2 = E(u2.cloneOf)) : re(e2) ? (ce(0, "hydrate(domain, { values })", "fork({ values })"), f2 = E(e2)) : r(0, "first argument of hydrate should be domain or scope"), N(f2, (e3, t2) => {
    if (t2 && oe(i2, t2)) {
      ie(l2, e3);
      const r2 = G(e3, "serialize");
      r2 && "ignore" !== r2 && (a2[t2] = r2.read(a2[t2])), ie(d2, a2[t2]);
    } else e3.scope.state.id in c2 && (ie(l2, e3), ie(d2, s2.get(c2[e3.scope.state.id])));
  }, 1), o({ target: l2, params: d2, scope: u2 }), p2 && Object.assign(u2.values.sidMap, a2);
}
function F(e2, { scope: t2, safe: n2 } = {}) {
  r(t2 || et || n2, "scopeBind: scope not found");
  const a2 = t2 || et;
  return (t3) => {
    function r2() {
      ot(s2);
    }
    let n3, o2 = 0;
    const s2 = et;
    ot(a2);
    try {
      n3 = e2(t3);
    } catch (e3) {
      n3 = e3, o2 = 1;
    }
    if (r2(), o2) throw n3;
    return n3 instanceof Promise && n3.then(r2, r2), n3;
  };
}
function q(t2, n2 = {}) {
  t2.warnSerialize && console.error("There is a store without sid in this scope, its value is omitted"), r(!t2.hasSidDoubles, "duplicate sid found in this scope");
  const a2 = n2.ignore ? n2.ignore.map(({ sid: e2 }) => e2) : [], o2 = {};
  return e(t2.values.sidMap, (e2, r2) => {
    var n3;
    if (oe(a2, r2)) return;
    const s2 = t2.sidIdMap[r2], i2 = null !== (n3 = t2.sidSerializeSettings.get(r2)) && void 0 !== n3 ? n3 : { ignore: 0, write: Tt };
    i2.ignore || (o2[r2] = (0, i2.write)(s2 && s2 in t2.reg ? t2.reg[s2].current : e2));
  }), "onlyChanges" in n2 && (ce(0, "onlyChanges"), n2.onlyChanges || (r(t2.cloneOf, "scope should be created from domain"), N(E(t2.cloneOf), (e2, r2) => {
    r2 in o2 || oe(a2, r2) || G(e2, "isCombine") || "ignore" === G(e2, "serialize") || (o2[r2] = t2.getState(e2));
  }))), o2;
}
function D({ unit: e2, fn: t2, scope: r2, batch: n2 }) {
  const o2 = [Te.run({ fn: (e3) => t2(e3) })];
  n2 && o2.unshift(Te.compute({ priority: "sampler", batch: 1 })), Y(e2) && o2.unshift(Te.mov({ store: e2.stateRef, to: "stack" }));
  const s2 = Array.isArray(e2) ? e2 : [e2];
  if (r2) {
    const e3 = [], t3 = r2.additionalLinks;
    return s2.forEach((r3) => {
      const n3 = t3[r3.graphite.id] || [];
      t3[r3.graphite.id] = n3;
      const s3 = a({ node: P(o2, r3), meta: { watchOp: r3.kind } });
      n3.push(s3), e3.push(() => {
        const e4 = n3.indexOf(s3);
        -1 !== e4 && n3.splice(e4, 1), vt(s3);
      });
    }), u(() => {
      e3.forEach((e4) => e4());
    });
  }
  {
    const e3 = a({ node: o2, parent: s2, family: { owners: s2 } });
    return u(() => {
      vt(e3);
    });
  }
}
function P(e2, t2) {
  return Y(t2) ? [Te.mov({ store: t2.stateRef, to: "stack" }), ...e2] : e2;
}
var _ = "undefined" != typeof Symbol && Symbol.observable || "@@observable";
var E = (e2) => e2.graphite || e2;
var V = (e2) => e2.family.owners;
var T = (e2) => e2.family.links;
var L = (e2) => e2.stateRef;
var B = (e2) => e2.value;
var W = (e2) => e2.subscribers;
var H = (e2) => e2.parent;
var U = (e2) => e2.scope;
var G = (e2, t2) => E(e2).meta[t2];
var J = (e2, t2, r2) => E(e2).meta[t2] = r2;
var K = (e2) => e2.compositeName;
var Q = (e2) => (Me(e2) || $e(e2)) && "kind" in e2;
var X = (e2) => (t2) => Q(t2) && t2.kind === e2;
var Y = X("store");
var Z = X("event");
var ee = X("effect");
var te = (e2) => Q(e2) && !!e2.targetable;
var re = X("domain");
var ne = X("scope");
var ae = { __proto__: null, unit: Q, store: Y, event: Z, effect: ee, targetable: te, domain: re, scope: ne, attached: (e2) => ee(e2) && 1 == G(e2, "attached") };
var oe = (e2, t2) => e2.includes(t2);
var se = (e2, t2) => {
  const r2 = e2.indexOf(t2);
  -1 !== r2 && e2.splice(r2, 1);
};
var ie = (e2, t2) => e2.push(t2);
var ce = (e2, t2, r2, n2) => !e2 && console.error(`${n2 ? n2 + ": " : ""}${t2} is deprecated${r2 ? `, use ${r2} instead` : ""}`);
var le = () => {
  let e2 = 0;
  return () => "" + ++e2;
};
var de = le();
var ue = le();
var fe = le();
var pe = le();
var me;
var he = (e2) => {
  me = e2;
};
var ge = null;
var ye = (e2) => {
  me && me(e2, ge);
};
var be = () => ge && ge.template;
var ve = (e2) => (e2 && ge && ge.sidRoot && (e2 = `${ge.sidRoot}|${e2}`), e2);
var ke = ({ sid: e2, name: t2, loc: r2, method: o2, fn: s2 }) => n(a({ meta: { sidRoot: ve(e2), sid: e2, name: t2, loc: r2, method: o2, type: "factory" } }), s2);
var we = (e2, r2) => {
  const n2 = E(e2);
  t(r2, (e3) => {
    const t2 = E(e3);
    "domain" !== n2.family.type && (t2.family.type = "crosslink"), ie(V(t2), n2), ie(T(n2), t2);
  });
};
var Se = (e2 = []) => (Array.isArray(e2) ? e2 : [e2]).flat().map(E);
var $e = (e2) => "object" == typeof e2 && null !== e2;
var Me = (e2) => "function" == typeof e2;
var xe = (e2) => void 0 === e2;
var ze = (e2) => r($e(e2) || Me(e2), "expect first argument be an object");
var Ae = (e2, t2, n2, a2) => r(!(!$e(e2) && !Me(e2) || !("family" in e2) && !("graphite" in e2)), `${t2}: expect ${n2} to be a unit (store, event or effect)${a2}`);
var je = (e2, r2, n2) => {
  Array.isArray(e2) ? t(e2, (e3, t2) => Ae(e3, r2, `${t2} item of ${n2}`, "")) : Ae(e2, r2, n2, " or array of units");
};
var Ce = (e2, n2, a2 = "target") => t(Se(n2), (t2) => r(!G(t2, "derived"), `${e2}: derived unit in "${a2}" is not supported, use createStore/createEvent instead"`));
var Ne = (e2, { fn: t2 }, { a: r2 }) => t2(e2, r2);
var Ie = (e2, { fn: t2 }, { a: r2 }) => t2(r2, e2);
var Oe = (e2, { fn: t2 }) => t2(e2);
var Re = (e2, t2, r2, n2) => {
  const a2 = { id: ue(), type: e2, data: t2 };
  return r2 && (a2.order = { priority: r2 }, n2 && (a2.order.barrierID = ++Fe)), a2;
};
var Fe = 0;
var qe = ({ from: e2 = "store", store: t2, target: r2, to: n2 = r2 ? "store" : "stack", batch: a2, priority: o2 }) => Re("mov", { from: e2, store: t2, to: n2, target: r2 }, o2, a2);
var De = ({ fn: e2, batch: t2, priority: r2, safe: n2 = 0, filter: a2 = 0, pure: o2 = 0 }) => Re("compute", { fn: e2, safe: n2, filter: a2, pure: o2 }, r2, t2);
var Pe = ({ fn: e2 }) => De({ fn: e2, priority: "effect" });
var _e = (e2, t2, r2) => De({ fn: e2, safe: 1, filter: t2, priority: r2 && "effect" });
var Ee = (e2, t2, r2) => qe({ store: e2, to: t2 ? "stack" : "a", priority: r2 && "sampler", batch: 1 });
var Ve = (e2 = Oe, t2) => De({ fn: e2, pure: 1, filter: t2 });
var Te = { mov: qe, compute: De, filter: ({ fn: e2, pure: t2 }) => De({ fn: e2, filter: 1, pure: t2 }), run: Pe };
var Le = (e2) => ({ id: ue(), current: e2, initial: e2 });
var Be = ({ current: e2 }) => e2;
var We = (e2, t2) => {
  e2.before || (e2.before = []), ie(e2.before, t2);
};
var He = null;
var Ue = (e2, t2) => {
  if (!e2) return t2;
  if (!t2) return e2;
  let r2;
  return (e2.v.type === t2.v.type && e2.v.id > t2.v.id || Ye(e2.v.type) > Ye(t2.v.type)) && (r2 = e2, e2 = t2, t2 = r2), r2 = Ue(e2.r, t2), e2.r = e2.l, e2.l = r2, e2;
};
var Ge = [];
var Je = 0;
for (; Je < 6; ) ie(Ge, { first: null, last: null, size: 0 }), Je += 1;
var Ke = () => {
  for (let e2 = 0; e2 < 6; e2++) {
    const t2 = Ge[e2];
    if (t2.size > 0) {
      if (3 === e2 || 4 === e2) {
        t2.size -= 1;
        const e3 = He.v;
        return He = Ue(He.l, He.r), e3;
      }
      1 === t2.size && (t2.last = null);
      const r2 = t2.first;
      return t2.first = r2.r, t2.size -= 1, r2.v;
    }
  }
};
var Qe = (e2, t2, r2, n2, a2, o2, s2) => Xe(0, { a: null, b: null, node: r2, parent: n2, value: a2, page: t2, scope: o2, meta: s2 }, e2, 0);
var Xe = (e2, t2, r2, n2) => {
  const a2 = Ye(r2), o2 = Ge[a2], s2 = { v: { idx: e2, stack: t2, type: r2, id: n2 }, l: null, r: null };
  3 === a2 || 4 === a2 ? He = Ue(He, s2) : (0 === o2.size ? o2.first = s2 : o2.last.r = s2, o2.last = s2), o2.size += 1;
};
var Ye = (e2) => {
  switch (e2) {
    case "child":
      return 0;
    case "pure":
      return 1;
    case "read":
      return 2;
    case "barrier":
      return 3;
    case "sampler":
      return 4;
    case "effect":
      return 5;
    default:
      return -1;
  }
};
var Ze = /* @__PURE__ */ new Set();
var et;
var tt = 1;
var rt = 0;
var nt = 0;
var at = null;
var ot = (e2) => {
  et = e2;
};
var st = (e2) => {
  at = e2;
};
var ct = (e2, t2) => {
  if (e2) {
    for (; e2 && !e2.reg[t2]; ) e2 = e2.parent;
    if (e2) return e2;
  }
  return null;
};
var lt = (e2, t2, r2, n2) => {
  const a2 = ct(e2, r2.id);
  return a2 ? a2.reg[r2.id] : t2 ? (pt(t2, r2, n2), t2.reg[r2.id]) : r2;
};
var dt;
var ut = (e2) => {
  dt = e2;
};
var ft = (e2) => e2;
var pt = (e2, r2, n2, a2, o2) => {
  const s2 = e2.reg;
  if (s2[r2.id]) return;
  const i2 = r2.sid, c2 = { id: r2.id, current: r2.initial, meta: r2.meta };
  if (c2.id in e2.values.idMap) c2.current = e2.values.idMap[c2.id];
  else if (i2 && i2 in e2.values.sidMap && !(i2 in e2.sidIdMap)) {
    var l2;
    const t2 = null == r2 || null === (l2 = r2.meta) || void 0 === l2 ? void 0 : l2.serialize;
    c2.current = (e2.fromSerialize && "ignore" !== t2 && (null == t2 ? void 0 : t2.read) || ft)(e2.values.sidMap[i2]);
  } else if (r2.before && !o2) {
    let o3 = 0;
    const i3 = n2 || !r2.noInit || a2;
    t(r2.before, (t2) => {
      switch (t2.type) {
        case "map": {
          const r3 = t2.from;
          if ((r3 || t2.fn) && (r3 && pt(e2, r3, n2, a2), i3)) {
            const e3 = r3 && s2[r3.id].current;
            c2.current = t2.fn ? t2.fn(e3) : e3;
          }
          break;
        }
        case "field":
          pt(e2, t2.from, n2, a2), o3 || (o3 = 1, c2.current = Array.isArray(c2.current) ? [...c2.current] : { ...c2.current }), i3 && (c2.current[t2.field] = s2[s2[t2.from.id].id].current);
      }
    });
  }
  i2 && (e2.sidIdMap[i2] = r2.id), s2[r2.id] = c2;
};
var mt = (e2, t2, r2) => {
  try {
    return t2(B(r2), e2.scope, r2);
  } catch (t3) {
    console.error(t3), e2.fail = 1, e2.failReason = t3;
  }
};
var ht = (t2, r2 = {}) => ($e(t2) && (ht(t2.or, r2), e(t2, (e2, t3) => {
  xe(e2) || "or" === t3 || "and" === t3 || (r2[t3] = e2);
}), ht(t2.and, r2)), r2);
var gt = (e2, t2) => {
  se(e2.next, t2), se(V(e2), t2), se(T(e2), t2);
};
var yt = (e2, t2, r2) => {
  let n2;
  e2.next.length = 0, e2.seq.length = 0, e2.scope = null;
  let a2 = T(e2);
  for (; n2 = a2.pop(); ) gt(n2, e2), (t2 || r2 && "sample" !== e2.meta.op || "crosslink" === n2.family.type) && yt(n2, t2, "on" !== n2.meta.op && r2);
  for (a2 = V(e2); n2 = a2.pop(); ) gt(n2, e2), r2 && "crosslink" === n2.family.type && yt(n2, t2, "on" !== n2.meta.op && r2);
};
var bt = (e2) => e2.clear();
var vt = (e2, { deep: t2 } = {}) => {
  let r2 = 0;
  if (e2.ownerSet && e2.ownerSet.delete(e2), Y(e2)) bt(W(e2));
  else if (re(e2)) {
    r2 = 1;
    const t3 = e2.history;
    bt(t3.events), bt(t3.effects), bt(t3.stores), bt(t3.domains);
  }
  yt(E(e2), !!t2, r2);
};
var kt = (e2) => u(() => vt(e2));
var wt = (e2, t2, r2, n2, o2) => a({ node: r2, parent: e2, child: t2, scope: { fn: o2 }, meta: { op: n2 }, family: { owners: [e2, t2], links: t2 }, regional: 1 });
var St = (e2) => {
  const t2 = "forward", [{ from: r2, to: n2 }, o2] = d(e2, 1), s2 = l(t2, o2);
  return ce(0, t2, "sample", s2), je(r2, s2, '"from"'), je(n2, s2, '"to"'), Ce(s2, n2, "to"), kt(a({ parent: r2, child: n2, meta: { op: t2, config: o2 }, family: {}, regional: 1 }));
};
var $t = (e2, t2) => (r(Me(t2), ".watch argument should be a function"), kt(a({ scope: { fn: t2 }, node: [Pe({ fn: Oe })], parent: e2, meta: { op: "watch" }, family: { owners: e2 }, regional: 1 })));
var Mt = (e2, t2, r2 = "event") => {
  H(e2) && H(e2).hooks[r2](t2);
};
var xt = (e2, t2, r2) => {
  const n2 = ht(r2), a2 = "domain" === e2, o2 = de(), { sid: s2 = null, named: i2 = null, domain: l2 = null, parent: d2 = l2 } = n2, u2 = i2 || n2.name || (a2 ? "" : o2), f2 = c(u2, d2), p2 = { op: t2.kind = e2, name: t2.shortName = u2, sid: t2.sid = ve(s2), named: i2, unitId: t2.id = o2, serialize: n2.serialize, derived: n2.derived, config: n2 };
  if (t2.targetable = !n2.derived, t2.parent = d2, t2.compositeName = f2, t2.defaultConfig = n2, t2.getType = () => (ce(0, "getType", "compositeName.fullName"), f2.fullName), !a2) {
    t2.subscribe = (e4) => (ze(e4), t2.watch(Me(e4) ? e4 : (t3) => e4.next && e4.next(t3))), t2[_] = () => t2;
    const e3 = be();
    e3 && (p2.nativeTemplate = e3);
  }
  return p2;
};
var zt = (e2, t2, r2, n2) => {
  let a2;
  $e(r2) && (a2 = r2, r2 = r2.fn);
  const o2 = p({ name: `${e2.shortName} → *`, derived: 1, and: a2 });
  return wt(e2, o2, n2, t2, r2), o2;
};
var At = "undefined is used to skip updates. To allow undefined as a value provide explicit { skipVoid: false } option";
var jt = (e2, t2, r2, n2, a2) => {
  const o2 = L(t2), s2 = qe({ store: o2, to: "a", priority: "read" });
  "map" === r2 && (s2.data.softRead = 1);
  const i2 = [s2, Ve(n2)];
  return f("storeOnMap", o2, i2, Y(e2) && L(e2)), wt(e2, t2, i2, r2, a2);
};
var Ct = (t2, n2, a2, o2, i2, c2) => {
  const d2 = l("combine", o2), u2 = t2 ? (e2) => [...e2] : (e2) => ({ ...e2 }), p2 = t2 ? [] : {}, m2 = u2(p2), g2 = Le(m2), y2 = Le(1);
  g2.type = t2 ? "list" : "shape", g2.noInit = 1, f("combineBase", g2, y2);
  const b2 = h(m2, { name: s(a2), derived: 1, ...c2, and: o2 }), v2 = L(b2);
  v2.noInit = 1, J(b2, "isCombine", 1);
  const k2 = Ee(g2);
  k2.order = { priority: "barrier" };
  const w2 = qe({ store: v2, to: "b", priority: "read" });
  w2.data.softRead = 1;
  const S2 = [_e((e2, t3, r2) => (r2.scope && !r2.scope.reg[g2.id] && (r2.c = 1), e2)), k2, qe({ store: y2, to: "b" }), _e((e2, { key: t3 }, r2) => {
    if (r2.c || e2 !== r2.a[t3]) return n2 && r2.b && (r2.a = u2(r2.a)), r2.a[t3] = e2, 1;
  }, 1), qe({ from: "a", target: g2 }), qe({ from: "value", store: 0, target: y2 }), qe({ from: "value", store: 1, target: y2, priority: "barrier", batch: 1 }), Ee(g2, 1, 1), i2 && Ve(), w2];
  if (e(a2, (e2, t3) => {
    if (!Y(e2)) return r(!Q(e2) && !xe(e2), `combine expects a store in a field ${t3}`, d2), void (m2[t3] = p2[t3] = e2);
    p2[t3] = e2.defaultState, m2[t3] = e2.getState();
    const n3 = wt(e2, b2, S2, "combine", i2);
    n3.scope.key = t3;
    const a3 = L(e2);
    We(g2, { type: "field", field: t3, from: a3 }), f("combineField", a3, n3);
  }), b2.defaultShape = a2, We(v2, { type: "map", from: g2, fn: i2 }), !be()) if (i2) {
    const e2 = i2(m2);
    !xe(e2) || c2 && "skipVoid" in c2 || console.error(`${d2}: ${At}`), v2.current = e2, v2.initial = e2, b2.defaultState = e2;
  } else b2.defaultState = p2;
  return b2;
};
var Nt = (e2, t2, r2) => {
  try {
    return [1, e2(...r2)];
  } catch (e3) {
    return t2(e3), [0, null];
  }
};
var It = (e2, t2, r2, n2, a2) => (s2) => {
  o({ target: [n2, Ot], params: [r2 ? { status: "done", params: e2, result: s2 } : { status: "fail", params: e2, error: s2 }, { value: s2, fn: r2 ? t2.rs : t2.rj }], defer: 1, page: a2.page, scope: a2.scope, meta: a2.meta });
};
var Ot = a({ node: [Pe({ fn: ({ fn: e2, value: t2 }) => e2(t2) })], meta: { op: "fx", fx: "sidechain" } });
var Rt = ["source", "clock", "target"];
var Ft = (e2, t2) => e2 + `: ${t2} should be defined`;
var qt = (e2, t2, n2, a2, o2, s2, i2, c2, d2, u2, m2, y2) => {
  const b2 = l(e2, c2), v2 = !!o2;
  r(!xe(n2) || !xe(t2), Ft(b2, "either source or clock"));
  let k2 = 0;
  xe(n2) ? k2 = 1 : Q(n2) || (n2 = g(n2)), xe(t2) ? t2 = n2 : (je(t2, b2, "clock"), Array.isArray(t2) && (t2 = $(t2))), k2 && (n2 = t2), c2 || i2 || (i2 = n2.shortName);
  let w2 = "none";
  (m2 || a2) && (Q(a2) ? w2 = "unit" : (r(Me(a2), "`filter` should be function or unit"), w2 = "fn")), o2 ? (je(o2, b2, "target"), Ce(b2, o2)) : "none" === w2 && u2 && Y(n2) && Y(t2) ? o2 = h(s2 ? s2(Be(L(n2)), Be(L(t2))) : Be(L(n2)), { name: i2, sid: y2, or: c2 }) : (o2 = p({ name: i2, derived: 1, or: c2 }), f("sampleTarget", E(o2)));
  const S2 = Le();
  let M2 = [];
  if ("unit" === w2) {
    const [r2, n3, s3] = Pt(a2, o2, t2, S2, e2);
    s3 || M2.push(...Dt(n3)), M2.push(...Dt(r2));
  }
  const x2 = [];
  if (k2) d2 && x2.push(Ee(S2, 1, 1));
  else {
    const [r2, a3, s3] = Pt(n2, o2, t2, S2, e2);
    s3 || x2.push(...Dt(a3)), x2.push(Ee(r2, 1, d2));
  }
  const z2 = wt(t2, o2, [f("sampleSourceLoader"), qe({ from: "stack", target: S2 }), ...x2, ...M2, Ee(S2), "fn" === w2 && Ve((e3, t3, { a: r2 }) => a2(e3, r2), 1), s2 && Ve(Ne), f("sampleSourceUpward", v2)], e2, s2);
  return we(n2, [z2]), Object.assign(z2.meta, c2, { joint: 1 }), o2;
};
var Dt = (e2) => [Ee(e2), _e((e3, t2, { a: r2 }) => r2, 1)];
var Pt = (e2, t2, r2, n2, o2) => {
  const s2 = Y(e2), i2 = s2 ? L(e2) : Le(), c2 = Le(s2);
  return s2 || a({ parent: e2, node: [qe({ from: "stack", target: i2 }), qe({ from: "value", store: 1, target: c2 })], family: { owners: [e2, t2, r2], links: t2 }, meta: { op: o2 }, regional: 1 }), f("sampleSource", c2, i2, n2), [i2, c2, s2];
};
var _t = (e2, t2, r2, n2) => {
  const a2 = e2[t2];
  a2 && o({ target: a2, params: Array.isArray(a2) ? a2.map(() => r2) : r2, defer: 1, stack: n2 });
};
var Et = "23.2.2";
var Vt = (e2) => !e2.node.meta.isCombine || e2.parent && "combine" !== e2.parent.node.meta.op;
var Tt = (e2) => e2;

export {
  n,
  a,
  o,
  i,
  p,
  h,
  g,
  b,
  v,
  k,
  w,
  S,
  $,
  x,
  z,
  A,
  j,
  C,
  O,
  R,
  F,
  q,
  D,
  ae,
  he,
  ke,
  Te,
  ut,
  vt,
  St,
  Et
};
//# sourceMappingURL=chunk-334EXEQV.js.map
